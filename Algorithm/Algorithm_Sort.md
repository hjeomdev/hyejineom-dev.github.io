# 알고리즘 이론 정리
# 정렬

## 1) Bubble Sort
특징
- 그 모습이 거품처럼 몽글몽글 거려서...버블 소트?
- 구현은 간단하지만 비효율적임

과정(오름차순 정렬)
- 인접한 두 원소를 비교해서 크기가 순서대로 되어있지 않은 경우 서로 교환

시간복잡도 
- 최선 : T(n) = O(n^2)
- 평균 : T(n) = O(n^2)
- 최악 : T(n) = O(n^2)

## 2) Insertion Sort
특징
- 구현은 간단하지만 비효율적임
- 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다

과정(오름차순 정렬) 
1. 확인한 원소를 가르키는 인덱스A와 확인할 원소를 가르키는 인덱스B가 필요하다
2. A를 B와 크기 비교 한다
3. A보다 B가 더 작으면, A를 한칸 오른쪽으로 옮긴다. 계속 왼쪽 원소들을 차례로 크기 비교한다.
4. A보다 B가 더 크면, A인덱스를 오른쪽으로 옮겨서 원소를 확인했다는 것을 표시한다.
5. B인덱스를 오른쪽으로 옮겨서 반복

시간복잡도 
- 최선 : T(n) = O(n)
- 평균 : T(n) = O(n^2)
- 최악 : T(n) = O(n^2)

## 3) Selection Sort
특징
- 구현은 간단하지만 비효율적임

과정(오름차순 정렬)
1. 최소 원소 찾기
2. 가장 왼쪽 원소와 교환(가장 왼쪽으로 보내기)
 => 항상 앞쪽이 정렬되고 있다.
3. 맨 왼쪽 원소 제외
4. 반복

시간복잡도 
- 최선 : T(n) = O(n^2)
- 평균 : T(n) = O(n^2)
- 최악 : T(n) = O(n^2)

## 4) Quick Sort
특징
- 복잡하지만 효율적임

과정(오름차순 정렬)
1. 피벗으로 피벗보다 작은 것들, 피벗보다 큰 것들의 2개의 무리로 나눠짐
2. 무리 안에서도 피벗으로 정렬
3. 리스트의 크기가 0이나 1이 될 때까지 반복하고 합친다

시간복잡도 
- 최선 : T(n) = O(nlog2n)
- 평균 : T(n) = O(nlog2n)
- 최악 : T(n) = O(n^2)

## 5) Merge Sort
특징
- 복잡하지만 효율적임
- 임시배열이 필요하다
- 레코드가 크면 비효율적
- 안정적인 시간복잡도

과정(오름차순 정렬)
1. 배열을 같은 크기로 나눠서 부분배열로 만든다
2. 부분배열을 정렬한다
3. 하나의 배열로 합친다

시간복잡도 
- 최선 : T(n) = O(nlog2n)
- 평균 : T(n) = O(nlog2n)
- 최악 : T(n) = O(nlog2n)

## 6) Heap Sort
특징
- 복잡하지만 효율적임
- 힙은 1차원 배열로 표현 가능
- 최대힙에서 최댓값 부터 삭제

과정(내림차순 정렬)
1. 최대힙에 삽입
2. 최대힙에서 삭제 -> 배열 삽입

시간복잡도 
- 최선 : T(n) = O(nlog2n)
- 평균 : T(n) = O(nlog2n)
- 최악 : T(n) = O(nlog2n)

## 7) Radix Sort 
특징
- 복잡하지만 효율적임
- 자리수로 크기 비교

과정(오름차순 정렬)
1. 일의 자리 크기 비교 후 Queue에 넣기
2. 십의 자리 크기 비교 후 Queue에 넣기
...
3. Queue대로 차례대로 가져와서 배열에 넣기

시간복잡도 
- T(n) = O(n)