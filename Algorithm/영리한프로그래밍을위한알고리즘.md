# 영리한 프로그래밍을 위한 알고리즘

- 링크: [영리한 프로그래밍을 위한 알고리즘 강좌](https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%95%EC%A2%8C)
- 기간: 2021. 10. 30 ~ 2021. 11. 24



[TOC]



## 순환 Recursion (2021. 10. 30 - 11. 01)

**무한루프**

- base case & recursion case

```java
public class Code02 {
  public static void main(String[] args) {
    int n = 4;
    func(n); // Hello 4번 출력
  }
  
  public static void func(int k) {
    if (k <= 0) { // base case: 적어도 하나의 recursion case에 빠지지 않는 경우가 존재해야 한다
      return;
    } else {
      System.out.println("Hello");
      func(k-1); // recursion case: 순환을 반복하다보면 결국 base case에 수렴해야 한다
    }
  }
}
```

- 수학적 귀납법 이용

```java
public class Code03 {
  public static void main(String[] args) {
    int result = func(4); //10
  }
  
  public static void func(int n) { // 0~n까지 더하는 함수
    if (n == 0) { // n이 0이면, 답은 0이다
      return 0;
    } else {
      return n + func(n-1); // n이 0보다 크다면, 0과 n-1 사이의 정수의 합에 n을 더해라. -> 수학적 귀납법 이용
    }
  }
}
```



**Factorial 팩토리얼: n!**

```java
public static int factorial(int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n-1); // 수학적 귀납법 이용
  }
}
```

- 비슷한 예제: x^n 구하기


```text 
x^0  = 1
x^n = x*x^n-1 if (n > 0)
```

```java
public static double power(double x, int n) {
  if (n == 0) {
    return 1;
  } else {
    return x * power(x, n-1);
  }
}
```



**Fibonacci Number 피보나치**

```text
f0 = 0
f1 = 1
fn = fn-1 + fn-2 (n>1)
```

```java
public int fibonacci(int n){
  if (n > 2) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```



**최대공약수: Euclid Method**

```text
m >= n인 두 양의 정수 m, n에 대해서 m이 n의 배수이면 gcd(m, n) = n이고, 그렇지 않으면 gcd(m, n) = gcd(n, m%n)이다
```

```java
public static int gcd(int m, int n) {
  if(m < n) {
    int tmp = m; m = n; n = tmp; // swap m and n
  }
  
  if (m % n == 0) {
    return n;
  } else {
    return gcd(n, m%n);
  }
}
```

- Euclid Method: 좀더 단순한 버전

```java
public static int gcd(int p, int q) {
  if (q == 0) {
    return p;
  } else {
    return gcd(q, p%q);
  }
}
```



**문자열 길이 계산**

```java
public static int length(String str) {
  if(str.equlas("")) {
    return 0;
  } else {
    return 1 + length(str.substring(1));
  }
}
```



**문자열의 프린트**

```java
public static void printChars(String str) {
  if(str.length() == 0) {
    return;
  } else {
    System.out.println(str.charAt(0));
    printChars(str.substring(1));
  }
}
```



**문자열을 뒤집어 프린트**

```java
public static void printCharReverse(String str) {
  if(str.length() == 0) {
    return;
  } else {
		printCharReverse(str.substring(1));
    System.out.print(str.charAt(0));
  }
}
```



**2진수로 변환하여 출력**

```java
public void printInBinary(int n) {
  if(n < 2) {
    System.out.println(n);
  } else {
    printInBinary(n/2);
  }
}
```



**배열의 합 구하기**

```java
public static int sum(int n, int[] data) {
  if(n <= 0) {
    return 0;
  } else {
    return sum(n-1, data) + data[n-1]; // data[0]에서 data[n-1]까지의 합을 구하여 반환
  }
}
```



**데이터파일로부터 n개의 정수 읽어오기**

```java
public void readFrom(int n, int[] data, Scanner in) {
  if(n == 0) {
    return ;
  } else { 
    //Scanner in이 참조하는 파일로부터 n개의 정수를 입력받아 배열 data의 data[0], ..., data[n-1]에 저장한다
    readFrom(n-1, data, in);
    data[n-1] = in.nextInt();
  }
}
```



## Recursion vs. Iteration

- 모든 순환함수는 반복문(Iteration)으로 변경 가능
- 그 역도 성립함. 즉 **모든 반복문은 recursion으로 표현 가능함**
- 순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 함
- 하지만 함수 호출에 따른 오버헤드가 있음(매개변수 전달, 액티베이션 프레임 생성 등)















