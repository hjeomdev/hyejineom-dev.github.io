# 영리한 프로그래밍을 위한 알고리즘

- 링크: [영리한 프로그래밍을 위한 알고리즘 강좌](https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%95%EC%A2%8C)
- 기간: 2021. 10. 30 ~ 2021. 11. 30



[TOC]



## 순환 Recursion

**무한루프**

- base case & recursion case

```java
public class Code02 {
  public static void main(String[] args) {
    int n = 4;
    func(n); // Hello 4번 출력
  }
  
  public static void func(int k) {
    if (k <= 0) { // base case: 적어도 하나의 recursion case에 빠지지 않는 경우가 존재해야 한다
      return;
    } else {
      System.out.println("Hello");
      func(k-1); // recursion case: 순환을 반복하다보면 결국 base case에 수렴해야 한다
    }
  }
}
```

- 수학적 귀납법 이용

```java
public class Code03 {
  public static void main(String[] args) {
    int result = func(4); //10
  }
  
  public static void func(int n) { // 0~n까지 더하는 함수
    if (n == 0) { // n이 0이면, 답은 0이다
      return 0;
    } else {
      return n + func(n-1); // n이 0보다 크다면, 0과 n-1 사이의 정수의 합에 n을 더해라. -> 수학적 귀납법 이용
    }
  }
}
```



**Factorial 팩토리얼: n!**

```java
public static int factorial(int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n-1); // 수학적 귀납법 이용
  }
}
```

- 비슷한 예제: x^n 구하기


```text 
x^0  = 1
x^n = x*x^n-1 if (n > 0)
```

```java
public static double power(double x, int n) {
  if (n == 0) {
    return 1;
  } else {
    return x * power(x, n-1);
  }
}
```



**Fibonacci Number 피보나치**

```text
f0 = 0
f1 = 1
fn = fn-1 + fn-2 (n>1)
```

```java
public int fibonacci(int n){
  if (n > 2) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```



**최대공약수: Euclid Method**

```text
m >= n인 두 양의 정수 m, n에 대해서 m이 n의 배수이면 gcd(m, n) = n이고, 그렇지 않으면 gcd(m, n) = gcd(n, m%n)이다
```

```java
public static int gcd(int m, int n) {
  if(m < n) {
    int tmp = m; m = n; n = tmp; // swap m and n
  }
  
  if (m % n == 0) {
    return n;
  } else {
    return gcd(n, m%n);
  }
}
```

- Euclid Method: 좀더 단순한 버전

```java
public static int gcd(int p, int q) {
  if (q == 0) {
    return p;
  } else {
    return gcd(q, p%q);
  }
}
```



**문자열 길이 계산**

```java
public static int length(String str) {
  if(str.equlas("")) {
    return 0;
  } else {
    return 1 + length(str.substring(1));
  }
}
```



**문자열의 프린트**

```java
public static void printChars(String str) {
  if(str.length() == 0) {
    return;
  } else {
    System.out.println(str.charAt(0));
    printChars(str.substring(1));
  }
}
```



**문자열을 뒤집어 프린트**

```java
public static void printCharReverse(String str) {
  if(str.length() == 0) {
    return;
  } else {
		printCharReverse(str.substring(1));
    System.out.print(str.charAt(0));
  }
}
```



**2진수로 변환하여 출력**

```java
public void printInBinary(int n) {
  if(n < 2) {
    System.out.println(n);
  } else {
    printInBinary(n/2);
  }
}
```



**배열의 합 구하기**

```java
public static int sum(int n, int[] data) {
  if(n <= 0) {
    return 0;
  } else {
    return sum(n-1, data) + data[n-1]; // data[0]에서 data[n-1]까지의 합을 구하여 반환
  }
}
```



**데이터파일로부터 n개의 정수 읽어오기**

```java
public void readFrom(int n, int[] data, Scanner in) {
  if(n == 0) {
    return ;
  } else { 
    //Scanner in이 참조하는 파일로부터 n개의 정수를 입력받아 배열 data의 data[0], ..., data[n-1]에 저장한다
    readFrom(n-1, data, in);
    data[n-1] = in.nextInt();
  }
}
```



**Recursion vs. Iteration**

- 모든 순환함수는 반복문(Iteration)으로 변경 가능
- 그 역도 성립함. 즉 ==모든 반복문은 recursion으로 표현 가능함==
- 순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 함
- 하지만 함수 호출에 따른 오버헤드가 있음(매개변수 전달, 액티베이션 프레임 생성 등)



**순환적 알고리즘 설계**

- 적어도 하나의 base case, 즉 순환되지 않고 종료되는 case가 있어야 함
- 모든 case는 결국 base case로 수렴해야 함
- ==암시적 implicit 매개변수를 명시적 explicit 매개변수로 바꾸어라==



**순차탐색 Sequential Search**

  - Iteration 버전: 매개변수 암시화
      - 이 함수의 미션은 data[0]에서 data[n-1] 사이에서 target을 검색하는 것이다.
      - 하지만 검색 구간의 시작 인덱스 0은 보통 생략한다. 즉, 암시적 매개변수이다.

```java
int search(int[] data, int n, int target) { // 0 생략(암시), n으로 n-1 명시
  for(int i = 0; i < n; i++) {
    if(data[i] == target) {
      return i;
    }
    return -1; // 찾고 있는 값이 존재하지 않음.
  }
}
```



- Recursion 버전1: 매개 변수 명시화
  - 이 함수의 미션은 data[begin]에서 data[end] 사이에서 target을 검색하는 것이다.
  - 즉, 검색구간의 시작점을 명시적으로 정한다.
  - 이 함수를 search(data, 0, n-1, target)으로 호출한다면 Iteration 버전의 함수와 동일한 일을 한다.
```java
int search(int[] data, int begin, int end, int target) { // begin, end 명시, end를 data.length-1라고 표현할 수 도 있음
  if(begin > end) { // 찾고 있는 값이 존재하지 않음.
    return -1;
  } else if(target == data[begin]) {
    return begin;
  } else {
    return search(data, begin+1, end, target);
  }
}
```



- Recursion 버전2: 매개 변수 명시화
  - end를 앞으로 옮기면서 순환

```java
int search(int[] data, int begin, int end, int target) {
  if(begin > end) {
    return -1;
  } else if(target == data[end]) {
    return end;
  } else {
    return search(data, begin, end-1, target);
  }
}
```



- Recursion 버전3: 매개 변수 명시화
  - begin과 end 사이에  middle 이라는 인덱스의 값을 탐색하고 begin과 middle-1, middle+1과 end 사이를 탐색
  - 이진탐색과 다름

```java
int search(int[] data, int begin, int end, int target) {
  if(begin > end) {
    return -1;
  } else {
    int middle = (begin+end)/2;
    if(data[middle] == target) {
      return middle;
    } 
    int index = search(data, begin, middle-1, target);
    if(index != -1) {
      return index;
    } else {
      return search(data, middle+1, end, target);
    }
  } 
}
```


- 최대값 찾기 버전1
  - 이 함수의 미션은 data[begin]에서 data[end] 사이에서 최대값을 찾아 반환한다. begin <= end 라고 가정한다.

```java
int findMax(int[] data, int begin, int end) {
  if(begin == end) {
    return data[begin];
  } else {
    return Math.max(data[begin], findMax(data, begin+1, end))
  }
}
```



- 최댓값 찾기 버전2

```java
int findMax(int[] data, int begin, int end) {
  if(begin == end) {
    return data[begin];
  } else {
    int middle = (begin+end)/2;
    int max1 = findMax(data, begin, middle);
    int max2 = findMax(data, middle+1, end);
    return Math.max(max1, max2);
  }
}
```



**이진검색**

- 배열이 정열되어 있을 때 적용가능한 방법 (ex. 사전에서 단어찾기)

```java
public static int binarySearch(String[] items, String target, int begin, int end) { //Iteration이라면 begin과 end를 0, n-1로 표현
  if(begin > end) {
    return -1;
  } else {
    int middle = (begin+end)/2;
    int compResult = target.compareTo(items[middle]); // 같으면 0, 작으면 음수, 크면 양수 반환
    if(compResult == 0) {
      return middle;
    } else if(compResult < 0) {
      return binarySearch(items, target, begin, middle-1);
    } else {
      return binarySearch(items, target, middle+1, end);
    }
  }
}
```



**미로찾기 Maze**

- 현재 위치에서 출구까지 가는 경로가 있으려면
  1) 현재 위치가 출구이거나 혹은
  2) 이웃한 셀들 중 하나에서 현재 위치를 지나지 않고 출구까지 가는 경로가 있거나



- Decision Problem(답이 yes or no 인 문제) 버전
  - pseudo code 1

  ```java
  boolean findPath(x, y) { // (x, y)로 부터 출구가 있는지 판단하는 함수
    if(x, y) is the exit { // 1. 현재 위치가 출구인 경우
      return true;
    } else { // 2. 이웃한 셀들 중 하나에서 현재 위치를 지나지 않고 출구까지 가는 경로가 있거나
      for each neighbouring cell(x', y') of (x, y) do // (x, y) 상하좌우에 위치하는 셀 들
        if (x', y') is on the pathway // (x', y')가 경로인 경우 (벽이 아님)
          if findPath(x', y')
            return true;
          return false;
    }
  }
  ```
  
  - pseudo code 2: 방문 위치 저장

  ```java
  boolean findPath(x, y) {
    if(x, y) is the exit {
      return true;
    } else {
      mark (x, y) as a visited cell; // 방문 사실 저장
      for each neighbouring cell (x', y') of (x, y) do
        if (x', y') is on the pathway and not visited // (x', y')가 경로이고 방문하지 않은 경우
          if findPath(x', y')
            return true;
      return falase;
    }
  }
  ```
  
  - pseudo code 3: 2보다 호출이 많지만 가독성이 높아짐

  ```java
  boolean findPath(x, y) {
    if (x, y) is either on the wall or a visited cell {
      return false;
    } else if (x, y) is the exit {
      return true;
    } else {
      mark (x, y) as a visited cell;
      for each neighbouring cell (x', y') of (x, y) do // 경로인지 확인하지 않는다
        if findPath(x', y')
          return true;
      return false;
    }
  }
  ```



- class Maze

```java
public class Maze {
  private static int N = 8;
  private static int[][] maze = {
    {0, 0, 0, 0, 0, 0, 0, 1},
    {0, 1, 1, 0, 1, 1, 0, 1},
    {0, 0, 0, 1, 0, 0, 0, 1},
    {0, 1, 0, 0, 1, 1, 0, 0},
    {0, 1, 1, 1, 0, 0, 1, 1},
    {0, 1, 0, 0, 0, 1, 0, 1},
    {0, 0, 0, 1, 0, 0, 0, 1},
    {0, 1, 1, 1, 0, 1, 0, 1}
  }
  
  private static final int PATHWAY_COLOUR = 0; // white. 경로임.
  private static final int WALL_COLOUR = 1; // blue. 경로가 아님(벽임).
  private static final int BLOCKED_COLOUR = 2; // red. visited이며 출구까지의 경로상에 있지 않음이 밝혀진 cell
  private static final int PATH_COLOUR = 3; // green. visited이며 아직 출구로 가는 경로가 될 가능성이 있는 cell
  
  public static boolean findMazePath(int x, int y) {
    if(x < 0 || y < 0 || x >= N || y >= N) { // 좌표의 유효성 검사 (0 ~ n-1)
      return false;
    } else if(maze[x][y] != PATHWAY_COLOUR) { // 이미 visited(green or red)거나 wall(blue) 인 경우
      return false;
    } else if(x == N-1 && y == N-1) { // 출구인 경우
      maze[x][y] = PATH_COLOUR;
      return true;
    } else {
      maze[x][y] = PATH_COLOUR; // 방문했음.
      if(findMazePath(x-1, y) || findMazePath(x, y+1) 
         || findMazePath(x+1, y) || findMazePath(x, y-1)) {
        return true;
      }
      maze[x][y] = BLOCKED_COLOUR; // dead end. (x, y)를 지나지 않고 출구로 가는 경로가 없음
      return false;
    }
  }
  public static void main(String[] args) {
   	printMaze();
    findMazePath(0, 0);
    printMaze();
  }
}
```



**Counting Cells in a Blob**

- Binary 이미지
- 각 픽셀은 background pixel이거나 혹은 image pixel
- 서로 연결된 image pixel들의 집합을 blob이라고 부름
- 상하좌우 및 대각방향으로도 연결된 것으로 간주
- 입력:
  - N*N 크기의 2차원 그리드
  - 하나의 좌표 (x, y)
- 출력:
  - 픽셀 (x, y)가 포함된 blob의 크기,
  - (x, y)가 어떤 blob에도 속하지 않는 경우에는 0



- Recursive Thinking

  ```text
  현재 픽셀이 속한 blob의 크기를 카운트하려면
    현재 픽셀이 image color가 아니면
  		0을 반환한다
    현재 픽셀이 image color라면
      먼저 현재 픽셀은 카운트한다 (count = 1).
      현재 픽셀이 중복 카운트되는 것을 방지하기 위해 다른 색으로 칠한다.
      현재 픽셀에 이웃한 모든 픽셀들에 대해서 // 북, 북동, 동, 동남, 남, 남서, 서, 북서	
      	그 픽셀이 속한 blob의 크기를 카운트하여 카운터에 더해준다.
      카운터를 반환한다
  ```



- psuedo code

  ```java
  Algorithm for countCells(x, y)
    if the pixel (x, y) is outside the grid // (x, y) 유효성 검사
      the result is 0;
  	else if pixel (x, y) is not an image pixel or already counted
      the result is 0;
  	else
      set the colour of the pixel (x, y) to a read colour; // 이미 카운트되었음을 표시
  		the result is 1 plus the number of cells in each piece of the blob that includes a nearest neighbour
  ```



- class CountCells

```java
private static int BACKGROUND_COLOR = 0;
private static int IMAGE_COLOR = 1;
private static int ALREADY_COUNTED = 2;

public int countCells(int x, int y) {
  if(x < 0 || y < 0 || x >= N || y >= N) {
    return 0;
  } else if(grid[x][y] != IMAGE_COLOR) { // 0 or 2
    return 0;
  } else {
    grid[x][y] = ALREADY_COUNTED;
    return 1 + countCells(x-1, y+1) + countCells(x, y+1) + countCells(x+1, y+1) 
      + countCells(x-1, y) + countCells(x+1, y) 
      + countCells(x-1, y-1) + countCells(x, y-1) + countCells(x+1, y-1);
  }
}
```



**N Queens Problem**





## 정렬



### 검색트리

#### 이진검색트리

#### 레드블랙트리



## 해슁



## 그래프 알고리즘



## Case Study - Huffman Coding



## 동적계획법



## 보충강의











