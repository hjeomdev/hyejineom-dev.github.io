[토니의 인증과 인가](https://www.youtube.com/watch?v=y0xMXlOAfss)

**인증 Authentication**: 사용자의 신분을 확인

**인가 Authorization**: 회원의 권한을 확인



1. 인증하기 - Request Header

   - 사용자의 아이디 패스워드를 인코딩하여 HTTP Authorization 요청헤더에 넣어서 전송
   - 문제점: 매번 로그인해야한다.

2. 인증 유지하기 - Browser(Storage)

   - 아이디와 패스워드를 브라우저 스토리지(로컬, 세션, 쿠키 등)에 저장하여 사용
   - 문제점: 데이터가 raw하게 저장되어있고, 브라우저가 서버에 비해 상대적으로 보안 취약

3. 안전하게 인증하기 - Server

   1. Session
      - 인증되면 세션아이디와 해당 사용자의 아이디를 서버의 세션에 저장하고, 세션아이디를 클라이언트에 저장
      - 장점: 세션아이디를 가져가도 크게 보안적 이슈가 되지 못함. 세션아이디의 만료기한으로 유효기간 설정 가능. 세션 관리를 서버에서 하기 때문에 탈취된 세션아이디를 지우면 그만.
      - 문제점: 서버 여러 대와 로드밸런싱을 두게되면 사용자가 어느 서버에 접속하느냐에 따라 인증을 더 해야할 수 있다.
   2. Session DB
      - 인증 정보를 DB에 따로 관리
      - 장점: 어느 서버로 접속해도 세션 DB 한곳에서 관리하므로 사용자가 여러번 로그인할 필요가 없다.
      - 단점: 클라이언트가 많아지면 DB 과부하

4. 효율적으로 인증하기 - Token

   - JsonWebToken: 디코딩이 쉬우므로 민감한 정보를 넣으면 안된다.

     - 서버에서 비밀키로 JWT생성해서 액세스토큰이라는 이름으로 브라우저에 저장

     - JWT를 서버에 전송하면

       1. 서버에서 비밀키로 유효성 검사

       2. 사용자 정보 파악(이름, 만료시기, 권한)

   - 장점: 세션 DB 없이 여러 대의 서버가 각자 비밀키를 가지고 토큰을 생성하고 요청된 토큰 유효성을 검사한다.

   - 단점: 엑세스 토큰을 탈취하여 인증을 요청하면 악성사용자도 인증받을 수있다.

     - 대안방법: 리프레시 토큰
       1. 인증을 요청받으면 서버에서 액세스토큰과 리프레시토큰을 생성, 액세스 토큰은 저장하지 않고 리프레시 토큰만 저장소에 저장(만료기한: 액세스 토큰 < 리프레시토큰)
       2. 액세스토큰과 리프레시토큰을 브라우저에 저장
       3. 액세스 토큰으로 서버에 요청
          - 만약 토큰이 만료되었다면 만료되었다고 브라우저에 전송
          - 브라우저에서 액세스토큰과 리프레시토큰 둘다 서버에 전송
          - 리프레시토큰 저장소에서 해당 리프레시토큰을 조회하고, 새로 갱신한 액세스토큰을 반환한다.
     - 장점: 세션관리 필요없음
     - 단점: 토큰 관리 필요함. 토큰 탈취 유의.

5. 다른채널을 통해 인증하기 - OAuth



