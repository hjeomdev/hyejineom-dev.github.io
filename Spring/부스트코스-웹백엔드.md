# 부스트코스 웹 백엔드

- 링크: [부스트코스 웹 백엔드](https://www.boostcourse.org/web326/joinLectures/28762)
- 기간: 2021. 10. 30 ~ 2021. . 



[TOC]



## 1. SQL & JDBC 프로그래밍

### 1) MySQL

**데이터베이스와 데이터베이스 관리 시스템**

- Q> 데이터베이스와 데이터베이스 관리 시스템을 어린이도 알 수 있을 정도로 설명해주세요.
- A> 도서관에 있는 책들이 데이터베이스라고 한다면, 도서관 사서분들이나 도서 정보를 찾아주는 컴퓨터를 DBMS라고 볼 수 있습니다.



**데이터베이스의 기본개념 (정의)**

- 데이터의 집합 (a Set of Data)
- 여러 응용 시스템(프로그램)들의 통합된 정보들을 저장하여 운영할 수 있는 공용(share) 데이터의 집합
- 효율적으로 저장, 검색, 갱신할 수 있도록 데이터 집합들끼리 연관시키고 조직화되어야 한다.



**데이터베이스의 특성**

- 실시간 접근성(Real-time Accessability)
  - 사용자의 요구를 즉시 처리할 수 있다.
- 계속적인 변화(Continuous Evolution)
  - 정확한 값을 유지하려고 삽입·삭제·수정 작업 등을 이용해 데이터를 지속적으로 갱신할 수 있다.
- 동시 공유성(Concurrent Sharing)
  - 사용자마다 서로 다른 목적으로 사용하므로 동시에 여러 사람이 동일한 데이터에 접근하고 이용할 수 있다.
- 내용 참조(Content Reference)
  - 저장한 데이터 레코드의 위치나 주소가 아닌 사용자가 요구하는 데이터의 내용, 즉 데이터 값에 따라 참조할 수 있어야 한다.



**데이터베이스 관리 시스템 (Database Management System = DBMS)**

- 데이터베이스를 관리하는 소프트웨어

- 여러 응용 소프트웨어(프로그램) 또는 시스템이 동시에 데이터베이스에 접근하여 사용할 수 있게 한다

- 필수 3기능
  
  - 정의기능 :  데이터 베이스의 논리적, 물리적 구조를 정의
  - 조작기능 : 데이터를 검색, 삭제, 갱신, 삽입, 삭제하는 기능
  - 제어기능 :  데이터베이스의 내용 정확성과 안전성을 유지하도록 제어하는 기능
  
- Oracle, SQL Server, MySQL, DB2 등의 상용 또는 공개 DBMS가 있다.

  

**데이터베이스 관리 시스템의 장/단점**

- 장점

  - 데이터 중복이 최소화

  - 데이터의 일관성 및 무결성 유지

  - 데이터 보안 보장

- 단점
  - 운영비가 비싸다
  - 백업 및 복구에 대한 관리가 복잡
  - 부분적 데이터베이스 손실이 전체 시스템을 정지

[install and uninstall MySQL in Mac](https://whitepaek.tistory.com/16)

**MySQL 실행 (Mac)**

- 서버 실행

  ```shell
  mysql.server start
  ```

  - 실행 성공 메세지

    ```shell
    Starting MySQL
    . SUCCESS!
    ```

    

- [데몬](../OS/데몬)으로 실행

  ```shell
  brew services start mysql // 서비스 실행
  brew services restart mysql // 서비스 재시작
  ```

  - 데몬으로 실행되고 있는 프로그램 조회

    ```shell
    brew services list
    ```

    

**MySQL 종료**

- 서버 종료

  ```shell
  mysql.server stop
  ```

	- 실행 성공 메세지

    ```shell
    Shutting down MySQL
    
    .. SUCCESS!
    ```

- [데몬](../OS/데몬)으로 종료

  ```shell
  brew services stop mysql
  ```



### 2) SQL(Structured Query Language)

- SQL은 데이터를 보다 쉽게 검색하고 추가, 삭제, 수정 같은 조작을 할 수 있도록 고안된 컴퓨터 언어입니다.
- 관계형 데이터베이스에서 데이터를 조작하고 쿼리하는 표준 수단입니다.
- DML (Data Manipulation Language): 데이터를 조작하기 위해 사용합니다.
  - INSERT, UPDATE, DELETE, SELECT 등이 여기에 해당합니다.
- DDL (Data Definition Language): 데이터베이스의 스키마를 정의하거나 조작하기 위해 사용합니다.
  - CREATE, DROP, ALTER 등이 여기에 해당합니다.
- DCL (Data Control Language) : 데이터를 제어하는 언어입니다. 권한을 관리하고, 테이터의 보안, 무결성 등을 정의합니다.
  - GRANT, REVOKE 등이 여기에 해당합니다.



**Database 생성하기**

- MySQL 관리자 계정인 root로 데이터베이스 관리 시스템에 접속하겠다는 것입니다.

```markup
mysql –uroot  -p
```

window 사용자는 설치 시에 입력했던 암호를 입력합니다.

맥 사용자는 암호가 없으니 그냥 엔터를 입력하면 됩니다.

MySQL DBMS에 접속하면 “mysql>” 프롬프트가 보입니다.

- 관리자 계정으로 MySQL에 접속했다면, 다음과 같은 명령으로 데이터베이스를 생성합니다.

```markup
 mysql> create database DB이름;
```

우리는 다음과 같은 명령을 실행하여 DB이름을 “connectdb＂로 생성하도록 하겠습니다.

```markup
mysql> create database connectdb;
```



**Database 사용자 생성과 권한 주기**

- Database를 생성했다면, 해당 데이터베이스를 사용하는 계정을 생성해야 합니다.
- 또한, 해당 계정이 데이터베이스를 이용할 수 있는 권한을 줘야 합니다.
- 아래와 같은 명령을 이용해서 사용자 생성과 권한을 줄 수 있습니다.
- db이름 뒤의 * 는 모든 권한을 의미한다.
- @’%’는 어떤 클라이언트에서든 접근 가능하다는 의미이고, @’localhost’는 해당 컴퓨터에서만 접근 가능하다는 의미입니다.
- flush privileges는 DBMS에게 적용을 하라는 의미입니다.
- 해당 명령을 반드시 실행해줘야 합니다.

```markup
grant all privileges on db이름.* to 계정이름@'%' identified by ＇암호’;
grant all privileges on db이름.* to 계정이름@'localhost' identified by ＇암호’;
flush privileges;
```

- 사용자 계정이름은 'connectuser', 암호는 'connect123!@#', 해당 사용자가 사용하는 데이터베이스는 'connectdb'로 계정을 생성하려면 다음과 같이 명령을 수행합니다.

```markup
grant all privileges on connectdb.* to connectuser@'%' identified by 'connect123!@#';

grant all privileges on connectdb.* to connectuser@'localhost' identified by 'connect123!@#';

flush privileges;

// mysql 8버전: 사용자 생성(+비밀번호 설정) 후 권한 부여
CREATE USER connectuser@'%' identified by 'connect123!@#';
GRANT ALL PRIVILEGES ON connectdb.* TO connectuser@'%'WITH GRANT OPTION;
```

[MySQL 8버전 grant 관련 문서](https://dev.mysql.com/doc/refman/8.0/en/grant.html)



[![img](images/2_8_1_Database__%2C_.png)](https://www.boostcourse.org/web326/lecture/258481?isDesc=false#)

**생성한 Database에 접속하기**

- mysql -h호스트명 -uDB계정명 -p 데이터베이스 이름
  -  mysql -h127.0.0.1 -uconnectuser -p connect123!@# [enter]

- **실행한 모습**

[![img](images/2_8_1_Database_.png)](https://www.boostcourse.org/web326/lecture/258481?isDesc=false#)

- **다음과 같이 프롬프트가 보이면 성공**

**MySQL 연결끊기**

프롬프트에서 quit혹은 exit라고 입력합니다.

```markup
mysql> QUIT
mysql> exit
```

[![img](images/2_8_1_Mysql.png)](https://www.boostcourse.org/web326/lecture/258481?isDesc=false#)

- **다음과 같이 Bye라고 나오면 연결 끊기 성공**



**MySQL 버전과 현재 날짜 구하기**

```markup
mysql> SELECT VERSION(), CURRENT_DATE;
+-----------+--------------+
| VERSION() | CURRENT_DATE |
+-----------+--------------+
| 5.1.67    | 2013-01-05   |
+-----------+--------------+
1 row in set (0.00 sec)
```

프롬프트에서는 SQL을 입력합니다.

SQL은 semicolon (;)으로 끝납니다.

SQL은 쿼리(Query)라고 읽습니다.

쿼리는 DBMS에게 명령을 내릴 때 사용하는 문장이라고 생각하면 쉽습니다.

SELECT는 어떤 내용을 조회할 때 사용하는 키워드입니다.

MySQL은 쿼리에 해당하는 결과의 전체 row를 출력하고 마지막에 전체 row 수와 쿼리실행에 걸린 시간을 표시합니다.

 

**키워드는 대소문자를 구별하지 않는다.**

다음 쿼리들은 모두 같습니다.

```markup
mysql> SELECT VERSION(), CURRENT_DATE;
mysql> select version(), current_date;
mysql> SeLeCt vErSiOn(), current_DATE;
```

 

**쿼리를 이용해서 계산식의 결과도 구할 수 있다.**

 함수 및 수식 사용 예제

```markup
mysql> SELECT SIN(PI()/4), (4+1)*5;
+-------------+---------+
| SIN(PI()/4) | (4+1)*5 |
+-------------+---------+
|    0.707107 |      25 |
+-------------+---------+
```

 

**여러 문장을 한 줄에 연속으로 붙여서 실행가능하다.**

각 문장에 semicolon(;)만 붙혀 주면 됩니다.

```markup
mysql> SELECT VERSION(); SELECT NOW();
+--------------+
| VERSION()    |
+--------------+
| 3.22.20a-log |
+--------------+
+---------------------+
| NOW()               |
+---------------------+
| 2004 00:15:33 |
+---------------------+
```



**하나의 SQL은 여러 줄로 입력가능하다.**

MySQL은 문장의 끝을 라인으로 구분하는 것이 아니라 semicolon(;)으로 구분하기 때문에 여러 줄에 거쳐 문장을 쓰는 것도 가능합니다.

```markup
mysql> SELECT
    -> USER()
    -> ,
    -> CURRENT_DATE;
+--------------------+--------------+
| USER()             | CURRENT_DATE |
+--------------------+--------------+
| joesmith@localhost | 1999-03-18   |
+--------------------+--------------+
```

 

**SQL을 입력하는 도중에 취소할 수 있다.**

긴 쿼리를 작성하다가 중간에 취소해야 하는 경우에는 즉시 \c를 붙혀주면 됩니다.

```markup
mysql> SELECT

    -> USER()

    -> \c

mysql>
```

 

**DBMS에 존재하는 데이터베이스 확인하기**

작업하기 위한 데이터베이스를 선택하기 위해서는 어떤 데이터베이스가 존재하는지 알아보아야 합니다.

현재 서버에 존재하는 데이터베이스를 찾아보기 위해서 SHOW statement을 사용합니다.

```markup
mysql> show databases;
+-----------------------+
| Database               |
+-----------------------+
| information_schema |
| connectdb              |
+-----------------------+
2 rows in set (0.00 sec)
```

 

 

**사용중인 데이터베이스 전환하기**

Database을 선택하기 위해, “use” command 사용합니다.

```markup
mysql> use mydb;
```

데이터베이스를 전환하려면, 이미 데이터베이스가 존재해야 하며 현재 접속 중인 계정이 해당 데이터베이스를 사용할 수 있는 권한이 있어야 합니다.



**데이터를 저장하는 공간 테이블(Table)**

- 마이크로소프트의 엑셀(Excel)을 실행하면 표가 나옵니다. 이러한 표에 각종 값을 저장할 수 있습니다.
- 데이터베이스도 엑셀의 표와 유사한 테이블을 가질 수 있습니다.
- 엑셀과 다른 점은 데이터베이스를 생성해도 테이블은 존재하지 않는다는 것입니다.
- 테이블을 사용하려면 테이블을 생성하는 SQL을 사용해야 합니다.
- 그리고, 테이블에 값을 저장하려면 저장하기 위한 SQL을 사용해야 합니다.



**테이블(table)의 구성요소**

[![img](images/2_8_1_(table)_.PNG)](https://www.boostcourse.org/web326/lecture/258482/?isDesc=false#)

- **테이블(table)의 구성요소**

- 테이블 : RDBMS의 기본적 저장구조 한 개 이상의 column과 0개 이상의 row로 구성합니다.
- 열(Column) : 테이블 상에서의 단일 종류의 데이터를 나타냄. 특정 데이터 타입 및 크기를 가지고 있습니다.
- 행(Row) : Column들의 값의 조합. 레코드라고 불림. 기본키(PK)에 의해 구분. 기본키는 중복을 허용하지 않으며 없어서는 안 됩니다.
- Field : Row와 Column의 교차점으로 Field는 데이터를 포함할 수 있고 없을 때는 NULL 값을 가지고 있습니다.

​           

**현재 데이터베이스에 존재하는 테이블 목록 확인하기**

Database를 선택 후, Database의 전체 테이블 목록을 출력합니다.

```markup
mysql> show tables;

Empty set (0.02 sec)
```

“empty set” 은  데이터베이스에 어떤 테이블도 아직 생성되지 않았다는 것을 알려줍니다.



**SQL 연습을 위한 테이블 생성과 값의 저장**

examples.sql을 다운로드 합니다. [링크 바로가기](https://github.com/connect-boostcamp/boostcourse_fullstack_web/tree/master/part2)

터미널에서 examples.sql이 있는 폴더로 이동한 후, 다음과 같이 명령을 수행합니다.

명령을 수행한 후 암호를 입력합니다.

```markup
mysql   -uconnectuser  -p  connectdb   <  examples.sql
```

examples.sql에는 연습을 위한 테이블 생성문과 해당 테이블에 값을 저장하는 입력문이 존재합니다.

```markup
mysql –uconnectuser -p  connectdb
```

위의 명령으로 connectdb에 접속한 후 다음과 같이 명령을 수행합니다.

```markup
mysql> show tables
```

위의 명령은 접속한 db의 테이블 목록을 보는 명령입니다.

[![img](images/2_8_1_SQL_____.png)](https://www.boostcourse.org/web326/lecture/258482/?isDesc=false#)

- **SQL연습을 위한 테이블 생성과 값의 저장**

**테이블 구조를 확인하기 위한 DESCRIBE 명령**

table 구조를 확인하기 위해, DESCRIBE 명령을 사용할 수 있습니다.

짧게 DESC라고 사용해도 됩니다.

EMPLOYEE테이블의 구조를 확인해 봅시다.

```markup
mysql> desc EMPLOYEE;
```



 **데이터 조작어(Data Manipulation Language, DML)의 종류**

데이터 조작어는 모두 동사로 시작합니다.

시작하는 동사에 따라서 다음과 같은 4가지 조작어가 있습니다.

- SELECT – 검색
- INSERT - 등록
- UPDATE - 수정
- DELETE - 삭제



**SELECT 구문의 기본문형**

[![img](images/2_8_2_select__.PNG)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문의 기본문형**

**SELECT 구문 예제(전체 데이터 검색)**

- 전체 데이터 검색
- SELECT 뒤에 * 를 기술함으로써 나타낼 수 있다.

예제 : departments 테이블의 모든 데이터를 출력하시오.

```markup
  SELECT * FROM  DEPARTMENT;
```

[![img](images/2_8_2_select__-20211105203955846.png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제**

**SELECT 구문 예제(특정 컬럼 검색)**

- SELECT 뒤에 컬럼을 콤마(,)로 구별해서 나열

예제 : employee 테이블에서 직원의 사번(empno), 이름(name), 직업(job)을 출력하시오.

어떤 칼럼이 있는지는 desc명령으로 확인

```markup
select empno, name, job from employee;
```

[![img](images/2_8_2_select__(__).png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제(특정 컬럼 검색)**

**SELECT 구문 예제(컬럼에 Alias부여하기)**

- 컬럼에 대한 ALIAS(별칭)을 부여해서 나타내는 칼럼의 HEADING을 변경할 수 있다.

예제 : employee 테이블에서 직원의 사번(empno), 이름(name), 직업(job)을 출력하시오.

```markup
select empno as 사번, name as 이름, job as 직업 from employee;
```

[![img](images/2_8_2_select__(_alias).png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제(칼럼에 alias부여하기)**

**SELECT 구문 예제(컬럼의 합성(Concatenation))**

- 문자열 결합함수 concat 사용

예제 : employee 테이블에서 사번과 부서번호를 하나의 칼럼으로 출력하시오.

```markup
SELECT concat( empno, '-', deptno) AS '사번-부서번호' 
FROM employee;
```

[![img](images/2_8_2_select__(_).png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제(컬럼의 합성)**

**SELECT 구문 예제(중복행의 제거)**

- 중복되는 행이 출력되는 경우, DISTINCT 키워드로 중복행을 제거

예제1 : 사원 테이블의 모든 부서번호 출력하시오. (사원 수 만큼 출력된다.)

```markup
select deptno from employee;
```

[![img](images/2_8_2_select__(_)-20211105203957913.png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제(중복행의 제거)**

예제2 : 사원 테이블의 부서번호를 중복되지 않게 출력하시오.

```markup
select distinct deptno from employee;
```

[![img](images/2_8_2_select__(_)-2.png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제(중복행의 제거)-2**

**SELECT 구문 예제(정렬하기)**

[![img](images/2.PNG)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **ORDER BY 절**

**SELECT 구문 예제(정렬하기)**

예제 : employee 테이블에서 직원의 사번(empno), 이름(name), 직업(job)을 출력하시오.

단, 이름을 기준으로 오름차순 정렬합니다.

```markup
select empno, name, job from employee order by name;

select empno as 사번, name as 이름, job as 직업 from employee order by 이름;
```

[![img](images/2_8_2_select__(alias___).png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제(alias를 사용하지 않았을 경우)**

[![img](images/2_8_2_select__(alias__).png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제(alias를 사용했을 경우)**

**SELECT 구문 예제(정렬하기)**

예제 : employee 테이블에서 직원의 사번(empno), 이름(name), 직업(job)을 출력하시오.

단, 이름을 기준으로 내림차순 정렬합니다.

```markup
select empno, name, job from employee order by name desc;
```

[![img](images/2_8_2_select__(_____).png)](https://www.boostcourse.org/web326/lecture/258484/?isDesc=false#)

- **select 구문 예제(이름 기준 내림 차순 정렬하기 결과)**



**SELECT 구문 예제(특정 행 검색- where절)**



[![img](images/3.PNG)](https://www.boostcourse.org/web326/lecture/258485/?isDesc=false#)

- **SELECT 구문 예제(특정 행 검색- where절)**

- 산술비교 연산자

예제 : employee 테이블에서 고용일(hiredate)이 1981년 이전의 사원이름과 고용일을 출력하시오.

```markup
select name, hiredate from employee where hiredate < '1981-01-01';
```

[![img](images/2_8_2_select__(__-where).png)](https://www.boostcourse.org/web326/lecture/258485/?isDesc=false#)

- **select 구문 예제(특정 행 검색-where절)**

- 논리연산자

예제 : employee 테이블에서 부서번호가 30인 사원이름과 부서번호를 출력하시오.

```markup
select name, deptno from employee where deptno = 30;
```

[![img](images/2_8_2_select__(__-where)-2.png)](https://www.boostcourse.org/web326/lecture/258485/?isDesc=false#)

- **select 구문 예제(특정 행 검색-where절)-2**

- IN 키워드

예제 : employee 테이블에서 부서번호가 10또는 30인 사원이름과 부서번호를 출력하시오.

```markup
select name, deptno from employee where deptno in (10, 30);
```

[![img](images/2_8_2_select__(__-where)-3.png)](https://www.boostcourse.org/web326/lecture/258485/?isDesc=false#)

- **select 구문 예제(특정 행 검색-where절)-3**

- LIKE 키워드
- 와일드 카드를 사용하여 특정 문자를 포함한 값에 대한 조건을 처리
- % 는 0에서부터 여러 개의 문자열을 나타냄
- _ 는 단 하나의 문자를 나타내는 와일드 카드

예제 : employee 테이블에서 이름에 'A'가 포함된 사원의 이름(name)과 직업(job)을 출력하시오.

```markup
select name, job from employee where name like '%A%';
```

[![img](images/2_8_2_select__(__-where)-4.png)](https://www.boostcourse.org/web326/lecture/258485/?isDesc=false#)

- **select 구문 예제(특정 행 검색-where절)-4**

**SELECT 구문 예제(함수의 사용)**

- UCASE, UPPER

```markup
mysql> SELECT UPPER('SEoul'), UCASE('seOUL');
 +-----------------+-----------------+
  | UPPER('SEoul') | UCASE('seOUL') |
  +-----------------+-----------------+
  | SEOUL            | SEOUL            |
  +-----------------+-----------------+
```

from 다음에 테이블이 없을 경우에는 테이블에서 조회하는 것이 아닙니다.

- LCASE, LOWER

```markup
mysql> SELECT LOWER('SEoul'), LCASE('seOUL');
 +-----------------+-----------------+
  | LOWER('SEoul') | LCASE('seOUL') |
  +-----------------+-----------------+
  | seoul              | seoul             |
  +-----------------+-----------------+
```

- substring // 시작인덱스는 1

```markup
mysql> SELECT SUBSTRING('Happy Day',3,2); 
  +-----------------+-----------------+
  | SUBSTRING('Happy Day',3,2)      |
  +-----------------+-----------------+
  | pp                                       |
  +-----------------+-----------------+
```

- LPAD, RPAD // (기존 문자열, 채운 뒤 결과 문자열 길이, 채울 문자)

```markup
mysql> SELECT LPAD('hi',5,'?'),LPAD('joe',7,'*');
  +------------------+-------------------+
  | LPAD('hi',5,'?')    | LPAD('joe',7,'*')   |
  +------------------+-------------------+
  | ???hi               |           ****joe    |
  +------------------+-------------------+
```

- TRIM, LTRIM, RTRIM // 공백 제거

```markup
mysql> SELECT LTRIM(' hello '), RTRIM(' hello ');
+-------------------------------------+
| LTRIM(' hello ') | RTRIM(' hello ')  |
+-------------------------------------+
| 'hello '            | '  hello‘            |
+-------------------------------------+
mysql> SELECT TRIM(' hi '),TRIM(BOTH 'x' FROM 'xxxhixxx');
+----------------+-----------------------------------+
| TRIM(' hi ')     | TRIM(BOTH 'x' FROM 'xxxhixxx') |
+----------------+-----------------------------------+
| hi                 | hi                                       |
+----------------+-----------------------------------+
```

- ABS(x) : x의 절대값을 구합니다.

```markup
mysql> SELECT ABS(2), ABS(-2);
+-----------+------------+ 
| ABS(2)     | ABS(-2)    | 
+-----------+------------+ 
| 2            | 2             | 
+-----------+------------+
```

- MOD(n,m) % : n을 m으로 나눈 나머지 값을 출력합니다.

```markup
mysql> SELECT MOD(234,10), 253 % 7, MOD(29,9);
+----------------+------------+-------------+ 
| MOD(234,10)  | 253 % 7   | MOD(29,9) | 
+----------------+------------+-------------+ 
|      4.             |       1      |      2         | 
+----------------+------------+-------------+
```



**SELECT 구문(함수의 사용)**

- FLOOR(x) : x보다 크지 않은 가장 큰 정수를 반환합니다. BIGINT로 자동 변환합니다.
- CEILING(x) : x보다 작지 않은 가장 작은 정수를 반환합니다.
- ROUND(x) : x에 가장 근접한 정수를 반환합니다.
- POW(x,y) POWER(x,y) : x의 y 제곱 승을 반환합니다.
- GREATEST(x,y,...) : 가장 큰 값을 반환합니다.
- LEAST(x,y,...) : 가장 작은 값을 반환합니다.
- CURDATE(),CURRENT_DATE : 오늘 날짜를 YYYY-MM-DD나 YYYYMMDD 형식으로 반환합니다.
- CURTIME(), CURRENT_TIME : 현재 시각을 HH:MM:SS나 HHMMSS 형식으로 반환합니다.
- NOW(), SYSDATE() , CURRENT_TIMESTAMP : 오늘 현시각을 YYYY-MM-DD HH:MM:SS나 YYYYMMDDHHMMSS 형식으로 반환합니다. 
- DATE_FORMAT(date,format) : 입력된 date를 format 형식으로 반환합니다.
- PERIOD_DIFF(p1,p2) : YYMM이나 YYYYMM으로 표기되는 p1과 p2의 차이 개월을 반환합니다.



**SELECT 구문(CAST 형변환)**



[![img](images/4.png)](https://www.boostcourse.org/web326/lecture/258486/?isDesc=false#)

- **SELECT 구문 (CAST 형변환)**

예제

```markup
mysql> select cast(now() as date);
+---------------------+
| cast(now() as date) |
+---------------------+
| 2003-09-25          |
+---------------------+
1 row in set (0.00 sec)
mysql> select cast(1-2 as unsigned);
+----------------------------+
|   cast(1-2 as unsigned)    |
+----------------------------+
|  18446744073709551615 |
+----------------------------+
```

 

**SELECT 구문(그룹함수)**

[![img](images/2_8_2_select_().PNG)](https://www.boostcourse.org/web326/lecture/258486/?isDesc=false#)

- **SELECT 구문(그룹함수)**

**SELECT 구문 예제(그룹함수)**

예제 : employee 테이블에서 부서번호가 30인 직원의 급여 평균과 총합계를 출력하시오.

```markup
SELECT AVG(salary) , SUM(salary)
FROM employee
WHERE deptno = 30;
```

[![img](images/2_8_2_select__().png)](https://www.boostcourse.org/web326/lecture/258486/?isDesc=false#)

- **SELECT 구문 예제(그룹함수)**

**SELECT 구문 예제(그룹함수와 groupby 절)**

예제 : employee 테이블에서 부서별 직원의 부서번호, 급여 평균과 총합계를 출력하시오.

```markup
SELECT deptno, AVG(salary) , SUM(salary)
FROM employee
group by deptno;
```

 

[![img](images/2_8_2_select__(_groupby_).png)](https://www.boostcourse.org/web326/lecture/258486/?isDesc=false#)

- **SELECT 구문 예제(그룹함수와 groupby 절)**



**데이터 입력 (INSERT문)**

```markup
INSERT INTO 테이블명(필드1, 필드2, 필드3, 필드4, … ) 
        VALUES ( 필드1의 값, 필드2의 값, 필드3의 값, 필드4의 값, … )

INSERT INTO 테이블명
        VALUES ( 필드1의 값, 필드2의 값, 필드3의 값, 필드4의 값, … )
```

- 필드명을 지정해주는 방식은 디폴트 값이 세팅되는 필드는 생력할 수 있습니다.
- 필드명을 지정해주는 방식은 추 후, 필드가 추가/변경/수정 되는 변경에 유연하게 대처 가능합니다.
- 필드명을 생략했을 경우에는 모든 필드 값을 반드시 입력해야 합니다.

 

**데이터 입력 실습 (INSERT문)**

예제 : ROLE테이블에 role_id는 200, description에는 'CEO'로 한건의 데이터를 저장하시오.

```markup
insert into ROLE (role_id, description) values ( 200, 'CEO');
```

[![img](images/2_8_2___(INSERT).png)](https://www.boostcourse.org/web326/lecture/258487/?isDesc=false#)

**데이터 수정(UPDATE문)**

```markup
 UPDATE  테이블명
        SET  필드1=필드1의값, 필드2=필드2의값, 필드3=필드3의값, …
   WHERE  조건식
```

- 조건식을 통해 특정 row만 변경할 수 있습니다.
- 조건식을 주지 않으면 전체 로우가 영향을 미치니 조심해서 사용하도록 합니다.

[예제11] user 번호가 1인 사용자의 이름을 영문으로 바꾸고,  join_date을 현재 시간이 적용되도록 수정하시오.

```sql
update 
```



**데이터 수정 실습(UPDATE문)**

예제 : ROLE테이블에 role_id가 200일 경우 description을 'CTO'로 수정하시오.

```markup
update ROLE
set description = 'CTO'
where role_id = 200;
```

\* where절을 안줄 경우 모든 데이터가 수정되니 조심해야 합니다.

[![img](images/2_8_2___(UPDATE).png)](https://www.boostcourse.org/web326/lecture/258487/?isDesc=false#)

- **데이터 수정 실습(UPDATE문)**

**데이터 삭제(DELETE문)**

```markup
 DELETE
      FROM  테이블명
WHERE  조건식
    
```

- 조건식을 통해 특정 row만 삭제할 수 있습니다.
- 조건식을 주지 않으면 전체 로우가 영향을 미치니 조심해서 사용하도록 합니다.

[예제12] user 번호가 1인 사용자를 삭제하시오.



**데이터 삭제 실습(DELETE문)**

예제 : ROLE테이블에서 role_id는 200인 정보를 삭제하시오.

```markup
delete from ROLE where role_id = 200;
```

\* where절을 안줄 경우 모든 데이터가 삭제되니 조심해야 합니다.

[![img](images/2_8_2___(DELETE).png)](https://www.boostcourse.org/web326/lecture/258487/?isDesc=false#)

- **데이터 삭제 실습(DELETE 문)**

**생각해보기**

사원의 이름과 그 사원이 속한 부서명을 구하려면 어떻게 해야할까요?

이 경우엔 EMPLOYEE 테이블과 DEPARTMENT 테이블을 조인(Join)해야 합니다. 

select문과 join에 대해 알아보세요.



**MySQL 데이터 타입**

[![img](images/2_8_3_MySQL__-1.PNG)](https://www.boostcourse.org/web326/lecture/58936/?isDesc=false#)

- **MySQL 데이터 타입-1**

[![img](images/2_8_3_MySQL__-2.PNG)](https://www.boostcourse.org/web326/lecture/58936/?isDesc=false#)

- **MySQL 데이터 타입-2**

**테이블 생성**

```sql
create table 테이블명( 
          필드명1 타입 [NULL | NOT NULL][DEFAULT ][AUTO_INCREMENT], 
          필드명2 타입 [NULL | NOT NULL][DEFAULT ][AUTO_INCREMENT], 
          필드명3 타입 [NULL | NOT NULL][DEFAULT ][AUTO_INCREMENT], 
          ........... 
          PRIMARY KEY(필드명));
```

- 데이터 형 외에도 속성값의 빈 값 허용 여부는 NULL 또는 NOT NULL로 설정
- DEFAULT 키워드와 함께 입력하지 않았을 때의 초기값을 지정
- 입력하지 않고 자동으로 1씩 증가하는 번호를 위한 AUTO_INCREMENT

 

**테이블 생성 실습**

EMPLOYEE와 같은 구조를 가진 EMPLOYEE2 테이블을 생성하시오.

[![img](images/2_8_3___-20211105210235251.png)](https://www.boostcourse.org/web326/lecture/58936/?isDesc=false#)

- **테이블 생성 실습**

```sql
CREATE TABLE EMPLOYEE2(   
            empno      INTEGER NOT NULL PRIMARY KEY,  
           name       VARCHAR(10),   
           job        VARCHAR(9),   
           boss       INTEGER,   
           hiredate   VARCHAR(12),   
           salary     DECIMAL(7, 2),   
           comm       DECIMAL(7, 2),   
          deptno     INTEGER);
```

 

**테이블 수정 (컬럼 추가 / 삭제)**

```sql
alter table 테이블명
          add  필드명 타입 [NULL | NOT NULL][DEFAULT ][AUTO_INCREMENT];

alter table 테이블명
         drop  필드명;
```

 

**테이블 수정 실습 (컬럼 추가)**

실습 – EMPLOYEE2 테이블에 생일(birthdate)칼럼을 varchar(12)형식으로 추가하시오.

```sql
alter table EMPLOYEE2
add birthdate varchar(12);
```

[![img](images/2_8_3___().png)](https://www.boostcourse.org/web326/lecture/58936/?isDesc=false#)

- **테이블 수정 실습(컬럼추가)**

**테이블 수정 실습 (컬럼 삭제)**

실습 – EMPLOYEE2 테이블의 생일(birthdate)칼럼을 삭제하시오.

```sql
alter table EMPLOYEE2
drop birthdate;
```

[![img](images/2_8_3___()-20211105210235062.png)](https://www.boostcourse.org/web326/lecture/58936/?isDesc=false#)

- **테이블 수정 실습(컬럼추가삭제)**

**테이블 수정 (컬럼 수정)**

```sql
alter table  테이블명
     change  필드명  새필드명 타입 [NULL | NOT NULL][DEFAULT ][AUTO_INCREMENT];
```

- change 키워드를 사용하고 칼럼을 새롭게 재정의 (이름부터 속성까지 전부)

 

**테이블 수정 실습 (컬럼 수정)**

실습 – EMPLOYEE2 테이블의 부서번호(deptno)를 dept_no로 수정하시오.

```sql
alter table EMPLOYEE2
change deptno dept_no int(11);
```

[![img](images/2_8_3___()-20211105210235075.png)](https://www.boostcourse.org/web326/lecture/58936/?isDesc=false#)

- **테이블 수정 실습(컬럼수정)**

**테이블 이름 변경**

```sql
alter table  테이블명 rename 변경이름
```

 

**테이블 이름 변경 실습**

실습 – EMPLOYEE2 테이블의 이름을 EMPLOYEE3로 변경하시오.

```sql
alter table EMPLOYEE2
rename EMPLOYEE3;
```

[![img](images/2_8_3____.png)](https://www.boostcourse.org/web326/lecture/58936/?isDesc=false#)

- **테이블 이름 변경 실습**

**테이블 삭제하기**

```sql
drop table 테이블이름;
```

참고로, 제약 조건이 있을 경우에는 drop table 명령으로도 테이블이 삭제되지 않을 수 있습니다.

그럴 경우는 테이블을 생성한 반대 순서로 삭제를 해야합니다.

 

**테이블 삭제 실습**

\* 테이블 삭제 후 desc 명령을 수행하면, 존재하지 않는 테이블이라고 표시됩니다.

실습 – EMPLOYEE2 테이블을 삭제하시오.

```sql
drop table EMPLOYEE2;
```

[![img](images/2_8_3___.png)](https://www.boostcourse.org/web326/lecture/58936/?isDesc=false#)

- **테이블 삭제 실습**



### 3) 개발환경 설정

JAVA언어를 작성된 프로그램을 실행하기 위해선 JRE(Java SE Runtime Environment)가 필요합니다.

JAVA언어를 사용하는 개발자가 아니라 JAVA언어로 만들어진 프로그램을 실행하는 사용자라면 JRE만 컴퓨터에 설치하면 됩니다.

보통 사용자 입장에서 JAVA를 설치한다는 것은 JRE를 설치하는 것을 말합니다.

JAVA언어를 사용하는 개발자는 JAVA언어로 작성된 소스(Source)를 컴파일하고 관리할 필요가 있습니다.

이때 사용되는 도구를 JDK(Java SE Development Kit)라고 말합니다.

JDK안에는 JRE도 포함되어 있습니다.

컴파일한 결과를 실행하기 위해서는 JRE가 필요하기 때문입니다.



JDK를 설치한 이후에는 JDK를 콘솔(console) 환경에서 잘 실행될 수 있도록 시스템 환경 설정을 해야 합니다.

시스템 환경 설정을 하는 방법은 운영체제에 따라서 다릅니다. 



**JAVA 환경설정**

JDK설치가 완료되었다면, JDK에 대한 시스템 환경설정을 해야 합니다.

시스템 환경설정을 하는 방법은 운영체제마다 다릅니다.

운영체제 마다 시스템 환경설정하는 방법은 다르지만, 설정해야 할 환경변수의 이름은 같습니다.

설정해야 할 환경변수는 다음과 같은 3가지입니다.

- JAVA_HOME : JAVA가 설치된 경로를 지정
- CLASSPATH : JAVA 클래스가 있는 경로들을 지정
- PATH : JAVA 실행파일이 있는 경로를 추가

JAVA_HOME, CLASSPATH는 시스템 환경변수에 새롭게 추가될 환경 변수이고, PATH는 기존에 존재하는 환경 변수입니다.



**1. MS Windows 10에서의 환경설정**

MS Windows 10에서 JDK 관련된 환경변수를 설정해 보도록 하겠습니다.

[![img](images/11.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

- 

  찾기 버튼을 누른 다음에 "시스템 환" 까지 입력합니다. 그러면 검색 결과에 "시스템 환경 변수 편집"이라는 결과가 보여질 것입니다. "시스템 환경 변수 편집"을 선택합니다.

[![img](images/12.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

- 

  위와 같은 창이 열리면 "환경변수" 버튼을 클릭합니다.

[![img](images/13.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

- 

  시스템 변수 영역의 "새로 만들기"버튼을 클릭합니다.

[![img](images/14.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

- 

  위의 그림과 같이 변수이름엔 "JAVA_HOME"을 변수 값엔 JDK가 설치된 경로를 입력합니다. (파일 탐색기에서 해당 경로로 이동한 후 복사하여 붙이기를 추천합니다.)

[![img](images/15.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

- 

  위의 그림과 같이 "JAVA_HOME" 환경변수가 시스템 변수 영역에 추가된 것을 확인할 수 있습니다.

[![img](images/16.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

- 

  같은 방법으로 "CLASSPATH" 환경변수를 추가합니다. 값은 ".;%JAVA_HOME%\lib\tools.jar" 로 입력합니다. "%JAVA_HOME%"은 앞에서 설정한 JAVA_HOME 환경변수의 값으로 치환하라는 의미입니다.

[![img](images/17.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

- 

  시스템 변수 영역에서 PATH를 찾아서 선택한 후 "편집" 버튼을 클릭한 후 위의 그림과 같은 창이 열리면 우측의 "새로 만들기" 버튼을 클릭한 후 "%JAVA_HOME%\bin"을 입력합니다.

[![img](images/18.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

"윈도키 + R"을 입력하여 실행창이 열리도록 한 후, "cmd"라고 입력하고 엔터를 입력합니다.
이 때 cmd 콘솔(console)창이 열리게 됩니다.
해당 콘솔창에서 다음과 같이 내용을 입력합니다.

```java
java -version
javac -version
```

java 명령은 JAVA로 작성된 프로그램을 실행할 때 사용하는 명령이고, javac 명령은 java로 작성된 프로그램을 컴파일할 때 사용하는 명령입니다.

위의 그림과 같이 실행 결과가 보인다면 설치가 잘 된 것입니다.

만약 java는 잘 실행되는데 javac가 제대로 실행되지 않는다면, 시스템 환경 변수 설정이 잘못 설정되었거나 JDK가 아닌 JRE만 설치되었을 때입니다.

환경변수에 오타가 있는지 확인하고 알맞게 수정하여 주세요.

환경변수가 수정되었다면 cmd 콘솔창을 닫고 다시 cmd 콘솔창을 열어서 명령을 실행해야 합니다.

 

**2. Mac OS에서의 환경설정**

설치가 완료된 이후에, 터미널을 연 후 아래와 같이 명령을 내립니다.

```markup
cd /Library/Java/JavaVirtualMachines
ls -la
```

그러면 아래와 같이 보일 것입니다.

위에서 사용한 명령은 맥 터미널 명령입니다. ( 리눅스도 같은 명령을 사용할 수 있습니다. )

필자의 경우 2가지 버전의 jdk가 설치되어 있기 때문에 jdk1.8.0_121.jdk 와 jdk1.8.0_91.jdk 2가지가 보입니다.

처음 설치했다면 경로가 하나만 보일 것입니다.

[![img](images/1.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

```markup
cd /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home  
```

위와 같은 명령으로 경로를 이동해보세요.

중간에 있는 jdk1.8.0_121.jdk는 본인이 설치한 jdk와 같은 경로여야 합니다.

해당 경로를 JAVA_HOME 경로라고 합니다.

해당 경로에서 ls -la 명령을 내려보면 윈도우에서 설치한 JDK와 같은 내용이 보이는 것을 알 수 있을 것입니다.

이제 맥에서 JDK를 사용하기 위해서 환경설정을 해야 합니다.

먼저 다음과 같은 명령을 실행합니다.

```markup
sudo su -
```

위의 명령은 터미널에서 관리자로 권한을 바꾸겠다는 것을 의미합니다.

```markup
vi /etc/paths
```

위의 명령은 vi라는 에디터로 /etc/paths 라는 파일을 편집하겠다는 것을 의미합니다.

vi 에디터는 처음 사용하면 굉장히 어렵습니다.

인터넷에서 vi 에디터에 대한 사용법을 미리 공부한 후 사용해주세요.

에디터로 /etc/paths라는 파일을 열었다면 맨 아랫줄에 다음의 경로를 추가합니다.

```markup
/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/bin
```

그리고 파일을 저장합니다.

이렇게 저장을 한 후, 다시 터미널을 열면 어디서든 java명령을 실행할 수 있습니다.

이번엔 다음과 같은 명령으로 JAVA_HOME 과 CLASSPATH 환경변수를 지정합니다.

```markup
vi /etc/profile
```

위의 명령을 실행한 후 맨 아랫줄에 다음의 내용을 추가합니다.

```markup
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home
export CLASSPATH=.:$JAVA_HOME/lib/tools.jar
```

CLASSPATH=다음에 있는 문자열은 점(.) 과 콜론(:)입니다.

점은 현재 경로를 말하고 콜론은 구분자입니다.

CLASSPATH로 현재 경로와 $JAVA_HOME/lib/tools.jar를 지정하라는 것을 의미합니다.

자 위와 같이 설정하였다면 터미널을 종료 후 다시 실행합니다.

그리고 아래와 같이 명령을 내려봅시다.

```markup
java -version
```

아래의 그림과 같이 결과가 출력된다면 설치가 잘 된 것입니다.

[![img](images/2-20211105211256498.png)](https://www.boostcourse.org/web326/lecture/58949/?isDesc=false#)

**간단한 JAVA 프로그램 컴파일 및 실행**

메모장을 열어 "Hello.java"라는 파일로 다음의 내용을 저장합니다.

```java
public class Hello{
     public static void main(String args[]){
       System.out.println("hello world");
     }
}
```

어떤 디렉토리에 저장해도 상관은 없습니다.

저는 c:\temp 폴더에 저장하였습니다.

cmd 콘솔창을 연 후 다음과 같이 입력합니다.

c:\temp 가 아닌 다른 디렉토리에 저장하였을 경우에는 본인이 저장한 디렉토리를 입력하면 됩니다. 

```java
cd c:\temp
javac Hello.java
```

위의 명령은 Hello.java소스파일을 컴파일하라는 명령입니다.

컴파일 되면 Hello.class파일이 생성됩니다.

Hello.class파일이 생성되었다면, 다음의 명령으로 실행합니다.

```java
java Hello
```

"hello world"가 잘 출력되었다면, JDK설치부터 환경변수설정까지 잘 되었다는 것을 알 수 있습니다.



 

------

**생각해보기**

1. 자바로 작성된 프로그램을 실행하려면 JRE만 설치하면 됩니다. 이때는 환경변수를 설정할 필요가 없습니다.
2. 그런데, JDK를 설치할 때는 환경변수를 설정해야 합니다. 환경변수를 설정하는 이유가 무엇일까요?
3. 현재 설치된 JDK보다 높은 버전의 JDK를 설치했습니다. 이때 수정해야 할 환경변수는 무엇일까요?



**이클립스란?**

IBM에서 웹 스피어 스튜디오 애플리케이션 디벨로퍼(WebSpheare Studio Application Developer)란 이름으로 JAVA언어를 이용하여 개발되었던 것인데, 핵심 부분을 오픈 소스로 공개하여 지금의 이클립스로 발전하게 되었습니다.

이클립스는 윈도우, 맥, 리눅스 등 다양한 운영체제에서 동작하며, JAVA를 비롯한 다양한 프로그래밍 언어를 개발할 수 있는 통합 개발 환경( Integrated Development Environment, IDE)이라고 말할 수 있습니다.

통합 개발 환경이란 코딩, 디버그, 컴파일, 배포 등 프로그램 개발에 관련된 모든 작업을 하나의 프로그램 안에서 처리할 수 있도록 환경을 제공하는 소프트웨어라고 생각하면 됩니다.

이클립스는 플러그인 구조로 쉽게 기능을 추가할 수 있는 구조로 되어 있습니다.

이런 구조 때문에 이클립스 기반으로 만들어진 다양한 도구들이 존재합니다.

또한 이클립스는 윈도우, 맥, 리눅스 운영체제를 지원하기 때문에 대부분의 환경에서 사용할 수 있다는 장점이 있습니다.

2001년 세상에 첫선을 보인 이래로 지속적으로 발전하여 최고의 개발 도구 중의 하나로 사랑받고 있습니다.



이클립스를 이용하여 자바 웹 어플리케이션을 개발할 때 사용하려면 "Eclipse IDE for Java EE Developers"를 다운로드 받아야 합니다.



[![img](images/8.png)](https://www.boostcourse.org/web326/lecture/58950/?isDesc=false#)

이클립스를 다운로드 받을 때 보면, 다양한 종류의 이클립스가 있던 것을 볼 수 있었습니다.

이클립스는 플러그인(Plugin)이란 구조로 만들어져 있습니다.

이클립스에 다양한 플러그인을 설치함으로써 다양한 방식으로 사용할 수 있습니다.

이클립스에 아무 플러그인도 설치하지 않았다면, 빈 윈도우 화면이 보여질 것입니다.

"Eclipse IDE for Java EE Developers" 는 자바와 자바 웹 개발을 위한 플러그인들이 설치된 버전이라고 생각하면 됩니다.

(1)번 영역은 퍼스팩티브(Perspective)라고 합니다.

퍼스팩티브는 여러개의 뷰(View)와 에디터 영역, 메뉴 등으로 구성되어 있습니다.

우리는 자바 개발과 자바웹 개발을 위한 퍼스팩티브를 사용할 것입니다.

(2)번 영역은 뷰(View)라고 합니다.

이클립스는 다양한 뷰를 제공해줍니다.

파일 탐색기와 유사항 뷰부터 시작해서 서버실행화면을 보여주는 뷰 등 다양한 뷰를 제공합니다.

(3)번 영역은 에디터(Editor) 영역이라고 합니다.

보통 에디터가 위치하기 때문입니다. 에디터 영역에서 앞으로 JAVA코드를 작성할 것입니다.

 

**이클립스 설치 후 인코딩 설정하기**

프로젝트 내에서 JAVA, HTML, xml등의 다양한 종류의 파일이 사용되는데 파일마다 인코딩하는 방법이 다르면 글자가 깨지는 현상이 발생합니다.

이런 문제가 발생하지 않도록 인코딩을 설정해 두는 것이 좋습니다.

이 과정에서는 UTF-8로 설정하도록 하겠습니다.

아래와 같이 인코딩을 설정해 주세요.



[![img](images/1-20211105211502393.png)](https://www.boostcourse.org/web326/lecture/58950/?isDesc=false#)

- 

  Window -> Preferences 메뉴를 클릭합니다.

[![img](images/2-20211105211502550.png)](https://www.boostcourse.org/web326/lecture/58950/?isDesc=false#)

- 

  Preferences 다이얼로그가 열리면, General -> Workspace 메뉴를 활성화하고, 하단의 Text file encoding 메뉴에서 Other 라디오버튼을 클릭하고 UTF-8 로 선택하고 Apply 버튼을 클릭합니다. 이렇게 설정하면 주로 자바 파일들에 대한 기본 인코딩이 UTF-8 로 설정됩니다.

[![img](images/3-20211105211502488.png)](https://www.boostcourse.org/web326/lecture/58950/?isDesc=false#)

- **CSS Files**

  좌측 메뉴에서 Web을 활성화해주고 CSS Files 메뉴를 클릭하면 우측 메뉴가 바뀌는데 우측의 Encoding 항목에서 UTF-8을 선택하고 Apply 버튼을 눌러줍니다. 같은 방법으로 HTML Files, JSP Files 의 인코딩 설정도 바꿔줍니다.

[![img](images/4-20211105211502426.png)](https://www.boostcourse.org/web326/lecture/58950/?isDesc=false#)

- **HTML Files**

[![img](images/5.png)](https://www.boostcourse.org/web326/lecture/58950/?isDesc=false#)

- **JSP Files**

------

**생각해보기**

1. 이클립스는 자바로 만들어진 프로그램입니다. 이클립스가 실행되기 위해서 설치되어 있어야 할 프로그램은 무엇일까요?
2. 이클립스에 모든 플러그인을 제거하면 빈 윈도우만 남는다고 하였습니다. 플러그인을 제작할 수 있다면, 이 빈 윈도우에 플러그인을 채워 넣을 수 있을 것입니다. 이런 방식으로 개발하는 것을 이클립스 RCP(Rich Client Platform)이라고 말합니다. 이클립스 RCP를 이용하여 만들어진 소프트웨어에는 어떤 것들이 있을까요?



**이클립스 프로젝트**

**Java Code Conventions (프로그래머들끼리의 약속)** 

- 클래스명 : 첫글자를 대문자로
- 프로젝트명, 패키지명 : 소문자

**참고 자료**

[**[참고링크\] 구글 Java 코딩 컨벤션**https://google.github.io](https://google.github.io/styleguide/javaguide.html)

[**[참고링크\] 자바 코딩 규칙(Java Code Conventions)**http://myeonguni.tistory.com](http://myeonguni.tistory.com/1596)

[**[참고링크\] Code Conventions for the Java Programming Language: Contents**http://www.oracle.comSUN Java 코딩 컨벤션](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html)



### 4) Maven

**Maven이란?**

Maven은 지금까지 애플리케이션을 개발하기 위해 반복적으로 진행해왔던 작업들을 지원하기 위하여 등장한 도구입니다. 

Maven을 사용하면 빌드(Build), 패키징, 문서화, 테스트와 테스트 리포팅, git, 의존성관리, svn등과 같은 형상관리서버와 연동(SCMs), 배포 등의 작업을 손쉽게 할 수 있습니다.

Maven을 이해하려면 CoC(Convention over Configuration)라는 단어를 먼저 이해해야 합니다.

CoC란 일종의 관습을 말하는데, 예를 들자면 프로그램의 소스파일은 어떤 위치에 있어야 하고, 소스가 컴파일된 파일들은 어떤 위치에 있어야 하고 등을 미리 정해놨다는 것입니다.

이 말은 관습에 이미 익숙한 사용자는 쉽게 Maven을 사용할 수 있는데, 관습에 익숙하지 않은 사용자는 이러한 제약사항에 대해서 심한 거부감을 느낄 수 있습니다.

Maven을 사용한다는 것은 어쩌면 이러한 관습 즉 CoC에 대해서 알아나가는 것이라고도 말할 수 있습니다. 



**Maven을 사용할 경우 얻게 되는 이점은?**

Maven을 사용할 경우, 굉장히 편리한 점들이 많습니다.

많은 사람이 손꼽는 장점 중에는 편리한 의존성 라이브러리 관리가 있습니다.

앞에서 JSTL을 학습할 때, 몇 가지 파일을 다운로드 하여 /WEB-INF/lib폴더에 복사하여 사용했었습니다.

관련된 라이브러리가 많아질수록 이러한 방식은 상당히 불편해집니다.

Maven을 사용하면 설정 파일에 몇 줄 적어줌으로써 직접 다운로드 받거나 하는 것을 하지 않아도 라이브러리를 사용할 수 있습니다.

프로젝트에 참여하는 개발자가 많아지게 되면, 프로젝트를 빌드하는 방법에 대하여 가이드하는 것도 쉬운 일이 아닙니다.

Maven을 사용하게 되면 Maven에 설정한 대로 모든 개발자가 일관된 방식으로 빌드를 수행할 수 있게 됩니다.

Maven은 또한 다양한 플러그인을 제공해줘서, 굉장히 많은 일들을 자동화시킬 수 있습니다.

 

**Maven 기본**

Archetype을 이용하여 Maven 기반 프로젝트를 생성할 경우 생성된 프로젝트 하위에 pom.xml 파일이 생성됩니다.

pom.xml 파일을 살펴보면 다음과 같습니다. 

```markup
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>kr.or.connect</groupId>
    <artifactId>examples</artifactId>
    <packaging>jar</packaging>
    <version>1.0-SNAPSHOT</version>
    <name>mysample</name>
    <url>http://maven.apache.org</url>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

각각의 태그의 의미는 다음과 같습니다.

- **project** : pom.xml 파일의 최상위 루트 엘리먼트(Root Element)입니다.
- **modelVersion** : POM model의 버전입니다. 
- **groupId** : 프로젝트를 생성하는 조직의 고유 아이디를 결정합니다. 일반적으로 도메인 이름을 거꾸로 적습니다.
- **artifactId** : 해당 프로젝트에 의하여 생성되는 artifact의 고유 아이디를 결정합니다. Maven을 이용하여 pom.xml을 빌드할 경우 다음과 같은 규칙으로 artifact가 생성됩니다. artifactid-version.packaging. 위 예의 경우 빌드할 경우 examples-1.0-SNAPSHOT.jar 파일이 생성됩니다.
- **packaging** : 해당 프로젝트를 어떤 형태로 packaging 할 것인지 결정합니다. jar, war, ear 등이 해당됩니다.
- **version** : 프로젝트의 현재 버전. 추후 살펴보겠지만 프로젝트가 개발 중일 때는 SNAPSHOT을 접미사로 사용합니다. Maven의 버전 관리 기능은 라이브러리 관리를 편하게 합니다.
- **name** : 프로젝트의 이름입니다.
- **url** : 프로젝트 사이트가 있다면 사이트 URL을 등록하는 것이 가능합니다.

Maven 을 이용할 경우 얻게 되는 큰 이점 중의 하나는 Dependency Management 기능입니다.

위 pom.xml 파일에서 <dependencies/> 엘리먼트가 Dependency Management 기능의 핵심이라고 할 수 있습니다.

해당 엘리먼트 안에 필요한 라이브러리를 지정하게 됩니다.



 

------

**생각해보기**

Maven은 정해진 관습을 사용하기 때문에, 처음 배울 때는 갑갑한 느낌이 듭니다.

이러한 관습에 빨리 익숙해지려면, 많이 찾아보고 사용해봐야합니다.

인터넷에서 pom.xml파일의 작성방법에 대해 조사해보세요.



 

------

**참고 자료**

[**[참고링크\] Maven – Welcome to Apache Maven**http://maven.apache.org](http://maven.apache.org/)



이번 시간에는 Maven을 이용해 웹 어플리케이션 프로젝트를 생성하고, 실행해보도록 하겠습니다.

이클립스를 실행하고, 이클립스의 메뉴 중 File - New - Project를 선택합니다.

[![img](images/maven01.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  프로젝트 위자드(Wizard)가 뜨면, Maven아래의 Maven Project를 선택한 후 Next버튼을 클릭합니다.

[![img](images/maven02.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  Maven프로젝트가 기존 워크스페이스 경로에 생성되도록 합니다. Next버튼을 클릭합니다.

[![img](images/maven03.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  아키타입(Archetype)을 선택합니다. 아키타입이란 일종의 프로젝트 템플릿(Template)이라고 말할 수 있습니다. 어떤 아키타입을 선택했느냐에 따라서 자동으로, 여러 가지 파일들을 생성하거나 라이브러리를 셋팅해주거나 등의 일을 해줍니다. Maven을 이용하여 웹 어플리케이션을 개발하기 위해서 maven-archetype-webapp를 선택한 후 Next 버튼을 클릭합니다.

[![img](images/maven04.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  Group Id는 보통 프로젝트를 진행하는 회사나 팀의 도메인 이름을 거꾸로 적습니다. Artifact Id는 해당 프로젝트의 이름을 적습니다. 버전은 보통 기본값(0.0.1-SNAPSHOT)으로 설정합니다. package이름은 group id와 Artifact Id가 조합된 이름이 됩니다. Group Id를 kr.or.connect이고 Artifact Id가 mavenweb으로 설정했기 때문에 package이름은 kr.or.connect.mavenweb이 됩니다. finish버튼을 클릭합니다.

[![img](images/maven05.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  프로젝트가 생성된 프로젝트의 디렉토리 구조입니다. 디렉토리의 구조를 보기 위해서 이클립스의 Navigator view를 통해서 확인하였습니다. Maven으로 생성된 프로젝트의 경우 자바 소스는 src/main/java 폴더에 생성됩니다. 웹 어플리케이션과 관련된 html, css등은 src/main/webapp 폴더에서 작성해야 합니다. 그런데, 생성된 프로젝트를 보면 src/main/java 폴더가 보이지 않습니다. 필요한 폴더는 별도로 만들어줄 필요가 있습니다.

[![img](images/_.PNG)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

[![img](images/maven06.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

[![img](images/maven07.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  프로젝트를 선택하고, 우측버튼을 눌러 properties를 선택합니다. 그리고, Java Compiler메뉴를 선택합니다. 선택을 해보면 기본적으로 JDK 1.5 버전을 사용하는 것을 알 수 있습니다. Maven으로 프로젝트를 생성하면 기본적으로 JDK 1.5를 사용하게 됩니다. JDK8을 사용하도록 하려면 Maven설정 파일인 pom.xml파일을 수정해야 합니다. pom.xml파일을 더블클릭하면 다음과 같이 보입니다.

[![img](images/maven08.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  아래쪽의 pom.xml 탭을 선택하면 소스가 보입니다.

```markup
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>kr.or.connect</groupId>
  <artifactId>mavenweb</artifactId>
  <packaging>war</packaging>
  <version>0.0.1-SNAPSHOT</version>
  <name>mavenweb Maven Webapp</name>
  <url>http://maven.apache.org</url>
  
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  <build>
    <finalName>mavenweb</finalName>
  </build>
</project>
```

자동으로 juint 3.8.1 라이브러리를 추가하고 있습니다.

junit은 테스트를 위한 라이브러리입니다.

위의 내용에 다음의 코드를 입력합니다.

```markup
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>kr.or.connect</groupId>
  <artifactId>mavenweb</artifactId>
  <packaging>war</packaging>
  <version>0.0.1-SNAPSHOT</version>
  <name>mavenweb Maven Webapp</name>
  <url>http://maven.apache.org</url>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  <build>
    <finalName>mavenweb</finalName>
        <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.6.1</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
            </configuration>
        </plugin>
    </plugins>
  </build>
</project>
```

코드를 입력하였으면, 저장합니다.

수정 후 다시 프로젝트 프로퍼티의 자바 컴파일러 항목을 보면 여전히 1.5 입니다.

[![img](images/maven09.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  프로젝트 프로퍼티를 선택한 후 Maven메뉴 아래의 Java EE Integration을 선택합니다. 보이는 것처럼 Enable Project Specific Settings 앞의 체크박스를 선택합니다. 그리고 아래의 Apply and Close버튼을 클릭합니다. 그리고, 다시 프로퍼티의 자바 컴파일러 버전을 확인하도록 하겠습니다. JDK 1.8이 사용되는 것을 알 수 있습니다. Maven의 설정을 바꾸면, 이클립스 프로젝트 설정이 연동되게 된 것입니다. 이번엔 webapp폴더 아래의 index.jsp를 열어보도록 하겠습니다.

[![img](images/maven10.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  HttpServlet을 찾을 수 없다는 오류 메시지가 보입니다. 다음에 배우게 되는 웹 백엔드 프로그래밍 기초 에서는 Dynamic Web Application을 만들 볼텐데요. 그 때는 WAS Runtime설정을 하면서 Tomcat을 지정합니다. Tomcat안에 있는 서블릿 라이브러리가 사용되면서 문제가 없게 됩니다. 실행시에도 WAS 위에서 실행되기 때문에 WAS의 서블릿 라이브러리를 사용하게 됩니다. Maven프로젝트로 생성했을 경우에는 WAS 런타임이 지정을 안 했기 때문에 서블릿 라이브러리를 찾을 수 없습니다. dependencies 엘리먼트 아래에 다음을 추가합니다.

```markup
<dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
        <scope>provided</scope>
    </dependency>
```

위의 내용을 보면 scope에 provided라는 항목이 있는데 servlet라이브러리를 컴파일 시에만 사용되고 배포 시에는 사용되지 않는다는 것을 의미합니다.

scope는 다음과 같은 4가지가 있습니다.

- **compile** : 컴파일 할 때 필요. 테스트 및 런타임에도 클래스 패스에 포함됩니다. scope 을 설정하지 않는 경우 기본값입니다.
- **runtime** : 런타임에 필요. JDBC 드라이버 등이 예가 됩니다. 컴파일 시에는 필요하지 않지만, 실행 시에 필요한 경우입니다.
- **provided** : 컴파일 시에 필요하지만, 실제 런타임 때에는 컨테이너 같은 것에서 제공되는 모듈. servlet, jsp api 등이 이에 해당. 배포 시 제외됩니다. 
- **test** : 테스트 코드를 컴파일 할 때 필요. 테스트 시 클래스 패스에 포함되며, 배포 시 제외됩니다.

위의 내용을 추가하고 index.html을 가보면 오류가 발생하지 않는 것을 알 수 있습니다.

[![img](images/maven11.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  해당 프로젝트를 실행해 보도록 하겠습니다. 프로젝트를 선택한 후 우측버튼을 클릭하여 Run on Server를 선택합니다. 해당 웹 어플리케이션을 실행할 Runtime을 지정하고, 항상 해당 런타임을 사용하겠다는 아래쪽 체크박스도 선택한 후 Finish버튼을 클릭합니다.

[![img](images/maven12.png)](https://www.boostcourse.org/web326/lecture/58938/?isDesc=false#)

- 

  브라우저가 실행되면서 index.html이 보여지는 것을 확인할 수 있습니다. 이번엔 pom.xml 파일에 JSTL라이브러리를 추가하도록 하겠습니다.

```markup
<dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>jstl</artifactId>
        <version>1.2</version>
    </dependency>
```

JSTL은 Tomcat이 기본으로 제공하지 않기 때문에, 컴파일할 때도 배포할 때도 사용돼야 합니다.

그래서 scope에 이번엔 provided가 있지 않습니다.

webapp폴더에 앞에서 작성했던 jstl02.jsp 를 붙여넣기를 하도록 하겠습니다.

라이브러리가 변경되었으니, 다시 run on server를 합니다.

실행해도 결과가 아무것도 나오지 않는 것을 확인할 수 있습니다.

프로젝트 프로퍼티를 선택한 후, Project facets 항목을 보면 다이나믹 웹 모듈의 버전이 2.3입니다.

다이나믹 웹 모듈의 2.4부터 EL이 기본으로 사용할 수 있도록 설정되기 때문에 2.3일 경우에는 EL표기법의 결과가 출력되지 않습니다.

앞의 프로젝트처럼 다이나믹 웹 모듈 3.1이 되도록 설정해보도록 하겠습니다.

먼저 WEB-INF의 web.xml 파일을 열어보도록 하겠습니다.

```markup
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>
</web-app>
```

위의 내용을 다음과 같이 수정합니다.

```markup
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1">
  <display-name>Archetype Created Web Application</display-name>
</web-app>
```

프로젝트아래의 .settings/org.eclipse.wst.common.project.facet.core.xml 파일을 엽니다.

Windows > Show veiw > Navigator로 파일을 보면 .settings 파일을 발견할 수 있습니다.

```markup
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <fixed facet="wst.jsdt.web"/>
  <installed facet="jst.web" version="2.3"/>
  <installed facet="wst.jsdt.web" version="1.0"/>
  <installed facet="java" version="1.8"/>
</faceted-project>
```

을 아래와 같이 수정합니다.

```markup
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <fixed facet="wst.jsdt.web"/>
  <installed facet="jst.web" version="3.1"/>
  <installed facet="wst.jsdt.web" version="1.0"/>
  <installed facet="java" version="1.8"/>
</faceted-project>
```

프로젝트 프로퍼티의 Project facets항목을 보면 다이나믹 웹 모듈이 3.1로 바뀐 것을 볼 수 있습니다.

이제 jstl02.jsp를 run on server로 실행합니다.

실행을 하지만 오류가 나면서 실행이 안 되는 경우가 있을 수 있습니다.

이클립스의 버그로, 수정되기 전의 데이터와 수정된 데이터가 섞여서 실행되기 때문입니다.

이 경우 웹 어플리케이션을 깔끔히 초기화하고 실행하는 것이 좋을 수 있습니다.

1. 기존 tomcat을 종료합니다.
2. 혹시 바뀌지 않았다면 프로젝트를 선택하고, 우측버튼을 눌러서 Maven 메뉴 아래의 update project를 선택한 후 확인하세요.
3. Servers view에서 기존 Tomcat Runtime을 삭제
4. Project 메뉴의 Clean선택
5. 프로젝트 익스플로러에서 Server 삭제

위와 같은 과정을 거친 후 Run on Server로 실행해보세요.

결과가 잘 나오는 것을 확인할 수 있습니다.

지금까지 배웠던 내용 중에서 가장 복잡한 것 같은데요.

다이나믹 웹 모듈을 2.3에서 3.1로 바꾸는 것은 프로젝트가 한번 만들어지면, 그 이후부터는 그 프로젝트가 더 이상 사용되지 않을 때까지 계속 사용되기 때문에 자주 개발자가 해야 할 일은 아닙니다.

그 이후부터는 pom.xml에 원하는 기능을 추가하면서 개발을 진행하면 됩니다.

수고하셨습니다.





------

**생각해보기**

1. 이클립스에는 Maven이 내장되어 있습니다. 이번 시간엔 이클립스에 내장된 Maven을 이용해 프로젝트를 생성해보았습니다. cmd창이나 터미널에서 maven명령을 수행해서 컴파일하고 실행할 수도 있습니다. 이를 위해선 Maven을 별도로 설치를 해야 합니다. Maven을 설치하고, 콘솔이나 터미널에서 실행할 방법을 찾아보세요.

 

 

------

**참고 자료**

[ ![img](images/Lf0S3YFdrvgmQ9rWzyay.png)**[참고링크\] How to Create Dynamic Web Project using Maven in Eclipse? • Crunchify**http://crunchify.com](http://crunchify.com/how-to-create-dynamic-web-project-using-maven-in-eclipse/)

[ ![img](images/X1b4hmMYJZxUIU3y2Qnh.png)**[참고링크\] How to fix Cannot change version of project facet Dynamic Web Module to 3.0 Error in Eclipse • Crunchify**http://crunchify.com](http://crunchify.com/how-to-fix-cannot-change-version-of-project-facet-dynamic-web-module-to-3-0-error-in-eclipse/)

[**[참고링크\] Maven in 5 Minutes**https://maven.apache.org](https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html)



### 5) JDBC

**JDBC 개요**

- JDBC(Java Database Connectivity)의 정의
  \- 자바를 이용한 데이터베이스 접속과 SQL 문장의 실행, 그리고 실행 결과로 얻어진 데이터의 핸들링을 제공하는 방법과 절차에 관한 규약
  \- 자바 프로그램 내에서 SQL문을 실행하기 위한 자바 API
  \- SQL과 프로그래밍 언어의 통합 접근 중 한 형태
- JAVA는 표준 인터페이스인 JDBC API를 제공
- 데이터베이스 벤더, 또는 기타 써드파티에서는 JDBC 인터페이스를 구현한 드라이버(driver)를 제공한다.



**JDBC 환경 구성**

- JDK 설치
- JDBC 드라이버 설치
  \- Maven에 다음과 같은 의존성을 추가한다. MySQL사이트에서 다운로드 한다.

```markup
<dependency>   
  <groupId>mysql</groupId>   
       <artifactId>mysql-connector-java</artifactId>
       <version>5.1.45</version>
 </dependency>
```

- [Java API Reference 참고 바로가기](https://docs.oracle.com/javase/8/docs/api/)
- [JDBC Tutorial 참고 바로가기](https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html)



**JDBC를 이용한 프로그래밍 방법**

1. import java.sql.*;
2. 드라이버를 로드 한다.
3. Connection 객체를 생성한다.
4. Statement 객체를 생성 및 질의 수행
5. SQL문에 결과물이 있다면 ResultSet 객체를 생성한다.
6. 모든 객체를 닫는다.



**JDBC 클래스의 생성 관계**

[![img](images/2_11_1_JDBC_.PNG)](https://www.boostcourse.org/web326/lecture/58939/?isDesc=false#)

**JDBC 사용 - 단계별 설명**

1. IMPORT

```java
import java.sql.*;
```

 

2. 드라이버 로드

```java
Class.forName( "com.mysql.jdbc.Driver" );
```

 

3. Connection 얻기

```java
String dburl  = "jdbc:mysql://localhost/dbName";

Connection con =  DriverManager.getConnection ( dburl, ID, PWD );
```

 

소스코드 예제

```java
public static Connection getConnection() throws Exception{
	String url = "jdbc:oracle:thin:@117.16.46.111:1521:xe";
	String user = "smu";
	String password = "smu";
	Connection conn = null;
	Class.forName("oracle.jdbc.driver.OracleDriver");
	conn = DriverManager.getConnection(url, user, password);
	return conn;
}
```

 

4. Statement 생성

```java
Statement stmt = con.createStatement();
```

 

5. 질의 수행

```java
ResultSet rs = stmt.executeQuery("select no from user" );

// 참고
stmt.execute(“query”);             //any SQL -> return true or false
stmt.executeQuery(“query”);     //SELECT -> return ResultSet
stmt.executeUpdate(“query”);   //INSERT, UPDATE, DELETE -> return row count
```

 

6. ResultSet으로 결과 받기

```java
ResultSet rs =  stmt.executeQuery( "select no from user" );
while ( rs.next() )
      System.out.println( rs.getInt( "no") );
```

 

7. Close

```java
rs.close();

stmt.close();

con.close();
```

 

소스코드 예제

```java
public List<GuestBookVO> getGuestBookList(){
		List<GuestBookVO> list = new ArrayList<>();
		GuestBookVO vo = null;
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try{
			conn = DBUtil.getConnection();
			String sql = "select * from guestbook";
			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while(rs.next()){
				vo = new GuestBookVO();
				vo.setNo(rs.getInt(1));
				vo.setId(rs.getString(2));
				vo.setTitle(rs.getString(3));
				vo.setConetnt(rs.getString(4));
				vo.setRegDate(rs.getString(5));
				list.add(vo);
			}
		}catch(Exception e){
			e.printStackTrace();
		}finally {
			DBUtil.close(conn, ps, rs);
		}		
		return list;		
	}
```

 

소스코드 예제

```java
public int addGuestBook(GuestBookVO vo){
		int result = 0;
		Connection conn = null;
		PreparedStatement ps = null;
		try{
			conn = DBUtil.getConnection();
			String sql = "insert into guestbook values("
					+ "guestbook_seq.nextval,?,?,?,sysdate)";
			ps = conn.prepareStatement(sql);
			ps.setString(1, vo.getId());
			ps.setString(2, vo.getTitle());
			ps.setString(3, vo.getConetnt());
			result = ps.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally {
			DBUtil.close(conn, ps);
		}
		
		return result;
	}
```

 

소스코드 예제

```java
public static void close(Connection conn, PreparedStatement ps){
		if (ps != null) {
			try {
				ps.close();
			} catch (SQLException e) {e.printStackTrace(); }
		}
		if (conn != null) {
			try {
				conn.close();
			} catch (SQLException e) {e.printStackTrace();}
		}
	}
```



 

------

**생각해보기**

java.sql패키지를 보면 대부분이 interface로 되어 있는 것을 알 수 있습니다.

이를 실제로 구현하는 것은 DBMS를 만든 회사입니다.

java.sql외에 JAVA가 인터페이스만 대부분 제공하는 패키지는 또 어떤 것이 있을까요?

참고로 XML문서의 표준은 w3c에서 정합니다.



**JDBC 실습1**

 **실습코드**

pom.xml

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>kr.or.connect</groupId>
	<artifactId>jdbcexam</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>jdbcexam</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	</properties>

	<dependencies>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.45</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>3.8.1</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>
```

 

Role.java

```java
package kr.or.connect.jdbcexam.dto;

public class Role {
	private Integer roleId;
	private String description;

	public Role() {

	}

	public Role(Integer roleId, String description) {
		super();
		this.roleId = roleId;
		this.description = description;
	}

	public Integer getRoleId() {
		return roleId;
	}

	public void setRoleId(Integer roleId) {
		this.roleId = roleId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	@Override
	public String toString() {
		return "Role [roleId=" + roleId + ", description=" + description + "]";
	}
}
```

 

RoleDao.java - Select

```java
package kr.or.connect.jdbcexam.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import kr.or.connect.jdbcexam.dto.Role;

public class RoleDao {
	private static String dburl = "jdbc:mysql://localhost:3306/connectdb";
	private static String dbUser = "connectuser";
	private static String dbpasswd = "connect123!@#";

	public Role getRole(Integer roleId) {
		Role role = null;
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;

		try {
			Class.forName("com.mysql.jdbc.Driver");
			conn = DriverManager.getConnection(dburl, dbUser, dbpasswd);
			String sql = "SELECT description,role_id FROM role WHERE role_id = ?";
			ps = conn.prepareStatement(sql);
			ps.setInt(1, roleId);
			rs = ps.executeQuery();

			if (rs.next()) {
				String description = rs.getString(1);
				int id = rs.getInt("role_id");
				role = new Role(id, description);
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (ps != null) {
				try {
					ps.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (conn != null) {
				try {
					conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}

		return role;
	}
}
```

 

jdbcExam1.java - Select

```java
package kr.or.connect.jdbcexam;

import kr.or.connect.jdbcexam.dao.RoleDao;
import kr.or.connect.jdbcexam.dto.Role;

public class JDBCExam1 {

	public static void main(String[] args) {
		RoleDao dao = new RoleDao();
		Role role = dao.getRole(100);
		System.out.println(role);
	}

}
```



**JDBC 실습2**

**실습코드**

RoleDao.java - Insert

```java
package kr.or.connect.jdbcexam.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import kr.or.connect.jdbcexam.dto.Role;

public class RoleDao {
	private static String dburl = "jdbc:mysql://localhost:3306/connectdb";
	private static String dbUser = "connectuser";
	private static String dbpasswd = "connect123!@#";

	public int addRole(Role role) {
		int insertCount = 0;

		try {
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		String sql = "INSERT INTO role (role_id, description) VALUES ( ?, ? )";

		try (Connection conn = DriverManager.getConnection(dburl, dbUser, dbpasswd);
				PreparedStatement ps = conn.prepareStatement(sql)) {

			ps.setInt(1, role.getRoleId());
			ps.setString(2, role.getDescription());

			insertCount = ps.executeUpdate();

		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return insertCount;
	}
}
```



JDBCExam2.java - Insert

```java
package kr.or.connect.jdbcexam;

import kr.or.connect.jdbcexam.dao.RoleDao;
import kr.or.connect.jdbcexam.dto.Role;

public class JDBCExam2 {
	public static void main(String[] args) {
		int roleId = 501;
		String description = "CTO";
		
		Role role = new Role(roleId, description);
		
		RoleDao dao = new RoleDao();
		int insertCount = dao.addRole(role);

		System.out.println(insertCount);
	}
}
```



**JDBC 실습 3**

**실습코드**

RoleDao.java - SELECT

```java
package kr.or.connect.jdbcexam.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import kr.or.connect.jdbcexam.dto.Role;

public class RoleDao {
	private static String dburl = "jdbc:mysql://localhost:3306/connectdb";
	private static String dbUser = "connectuser";
	private static String dbpasswd = "connect123!@#";

	public List<Role> getRoles() {
		List<Role> list = new ArrayList<>();

		try {
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}

		String sql = "SELECT description, role_id FROM role order by role_id desc";
		try (Connection conn = DriverManager.getConnection(dburl, dbUser, dbpasswd);
				PreparedStatement ps = conn.prepareStatement(sql)) {

			try (ResultSet rs = ps.executeQuery()) {

				while (rs.next()) {
					String description = rs.getString(1);
					int id = rs.getInt("role_id");
					Role role = new Role(id, description);
					list.add(role); // list에 반복할때마다 Role인스턴스를 생성하여 list에 추가한다.
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return list;
	}
}
```

 

JDBCExam3.java - SELECT

```java
package kr.or.connect.jdbcexam;

import java.util.List;

import kr.or.connect.jdbcexam.dao.RoleDao;
import kr.or.connect.jdbcexam.dto.Role;

public class JDBCExam3 {
	public static void main(String[] args) {

		RoleDao dao = new RoleDao();
		
		List<Role> list = dao.getRoles();

		for(Role role : list) {
			System.out.println(role);
		}
	} 
}
```

 

RoleDao.java - Delete

```java
package kr.or.connect.jdbcexam.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import kr.or.connect.jdbcexam.dto.Role;

public class RoleDao {
	private static String dburl = "jdbc:mysql://localhost:3306/connectdb";
	private static String dbUser = "connectuser";
	private static String dbpasswd = "connect123!@#";

	public int deleteRole(Integer roleId) {
		int deleteCount = 0;
		
		Connection conn = null;
		PreparedStatement ps = null;
		
		try {
			Class.forName( "com.mysql.jdbc.Driver" );
			
			conn = DriverManager.getConnection ( dburl, dbUser, dbpasswd );
			
			String sql = "DELETE FROM role WHERE role_id = ?";

			ps = conn.prepareStatement(sql);
			
			ps.setInt(1,  roleId);

			deleteCount = ps.executeUpdate();

		}catch(Exception ex) {
			ex.printStackTrace();
		}finally {
			if(ps != null) {
				try {
					ps.close();
				}catch(Exception ex) {}
			} // if
			
			if(conn != null) {
				try {
					conn.close();
				}catch(Exception ex) {}
			} // if
		} // finally

		return deleteCount;
	}
}
```

 

JDBCExam4.java - Delete

```java
package kr.or.connect.jdbcexam;

import kr.or.connect.jdbcexam.dao.RoleDao;

public class JDBCExam4 {
	public static void main(String[] args) {
//삭제 테스트
		int roleId = 500;

		RoleDao dao = new RoleDao();
		int deleteCount = dao.deleteRole(roleId);

		System.out.println(deleteCount);
	}
}
```

 

RoleDao.java - Update

```java
package kr.or.connect.jdbcexam.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import kr.or.connect.jdbcexam.dto.Role;

public class RoleDao {
	private static String dburl = "jdbc:mysql://localhost:3306/connectdb";
	private static String dbUser = "connectuser";
	private static String dbpasswd = "connect123!@#";
	
	public int updateRole(Role role) {
		int updateCount = 0;
		
		
		Connection conn = null;
		PreparedStatement ps = null;
		
		try {
			Class.forName( "com.mysql.jdbc.Driver" );
			
			conn = DriverManager.getConnection ( dburl, dbUser, dbpasswd );
			
			String sql = "update role set description = ? where role_id = ?";
			
			ps = conn.prepareStatement(sql);
			
			ps.setString(1, role.getDescription());
			ps.setInt(2,  role.getRoleId());
			
			updateCount = ps.executeUpdate();

		}catch(Exception ex) {
			ex.printStackTrace();
		}finally {
			if(ps != null) {
				try {
					ps.close();
				}catch(Exception ex) {}
			} // if
			
			if(conn != null) {
				try {
					conn.close();
				}catch(Exception ex) {}
			} // if
		} // finally
		
		return updateCount;
	}
}
```

 

JDBCExam5.java - Update

```java
package kr.or.connect.jdbcexam;

import kr.or.connect.jdbcexam.dao.RoleDao;
import kr.or.connect.jdbcexam.dto.Role;

public class JDBCExam5 {
	public static void main(String[] args) {
//수정테스트
		int roleId = 500;
		String description = "CEO";
		
		Role role = new Role(roleId, description);
		
		RoleDao dao = new RoleDao();
		int updateCount = dao.updateRole(role);

		System.out.println(updateCount);
	} 
}
```



[참고] Role 스키마 구조

```markup
mysql> describe Role;
+-------------+--------------+------+-----+---------+-------+
| Field       | Type         | Null | Key | Default | Extra |
+-------------+--------------+------+-----+---------+-------+
| role_id     | int(11)      | NO   | PRI | NULL    |       |
| description | varchar(100) | YES  |     | NULL    |       |
+-------------+--------------+------+-----+---------+-------+
```

 

------

**생각해보기**

1.  JDBC를 이용해서 입력/수정/삭제/조회 메소드를 만들다 보면, 반복적인 코드가 많다는 것을 알 수 있습니다.반복되는 부분을 별도의 메서드나 클래스로 추출한다면 어떤 부분의 중복을 제거할수 있을까요?
2.  JDK7부터 추가된 try-with-resource 구문을 이용한다면 예제 코드 중 어떤 부분을 줄일 수 있을까요? 



**프로젝트A. 명함 관리 프로그램**

```sql
 create table BUSINESSCARD (  
   name varchar(10) not null primary key,
   phone varchar(25), 
   companyName varchar(25), 
   createDate datetime DEFAULT CURRENT_TIMESTAMP);
```





## 2. 웹 백엔드 프로그래밍 기초

### 1) 웹 프로그래밍을 위한 프로그램 언어들

### 2) 웹 개발환경 설정

### 3) Servlet

### 4) JSP

### 5) scope

### 6) JSTL & EL



## 3~6. 웹 앱 개발 예약 서비스

### 1) Spring Core

### 2) Spring Test

### 3) Spring JDBC

### 4) Spring MVC

### 5) 레이어드 아키텍처

### 6) WEB API

### 7) Controller

### 8) Swagger

### 9) 상태유지기술 (Cookie & Session)

### 10) Spring에서의 Session 사용법

### 11) Spring Security

### 12) 인터셉터

### 13) 아큐먼트 리졸버

### 14) 로깅

### 15) 파일 업로드 & 다운로드