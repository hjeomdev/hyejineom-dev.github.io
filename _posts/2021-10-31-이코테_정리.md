---
layout: post
title:  "이것이취업을위한코딩테스트이다2021"
date:   2021-10-31 21:03:36 +0530
categories: Python Algorithm
---

[TOC]

출처: [이것이취업을위한코딩테스트이다2021](https://www.youtube.com/playlist?list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC)

# 코딩테스트 출제 경향 분석 및 파이썬 문법 부수기

## 알고리즘 성능평가

### 시간복잡도

알고리즘 수행 시간 분석

### 공간복잡도

알고리즘의 메모리 사용량 분석

*동일한 기능을 하는 알고리즘이 있다면, 일반적으로 복잡도가 낮을 수록 좋은 알고리즘이다*

### 빅오표기법 Big-O Notation

가장 빠르게 증가하는 항만 고려하는 표기법 == 함수의 상한만을 나타냄

|      | 순위     | 명칭                    |
| ---- | -------- | ----------------------- |
| 좋음 | O(1)     | 상수 시간 Constant time |
|      | O(logN)  | 로그 시간 Log time      |
|      | O(N)     | 선형 시간               |
| ↕️    | O(NlogN) | 로그 선형 시간          |
|      | O(N^2)   | 이차 시간               |
|      | O(N^3)   | 삼차 시간               |
| 나쁨 | O(2^n)   | 지수 시간               |

*요구사항에 맞게 적절한 알고리즘을 구상하여 작성하기*

## 알고리즘 문제 해결 과정

1. 지문읽기 및 컴퓨터적 사고
2. 요구사항(복잡도) 분석
3. 문제해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩

## 자료형

### 정수형

정수를 다루는 자료형(양의 정수, 0, 음의 정수)

```python
a = 100
print(a) # 100
```

### 실수형

소수점 아래의 데이터를 포함하는 수 자료형

소수부 0이나 정수부 0을 생략할 수 있음

```python
a = 3.141591
print(a) # 3.141591

a = 3.
print(a) # 3.0

a = -.9
print(a) # -0.9
```

#### 지수표현방식

유효숫자e지수 = 유효숫자 * 10^지수

임의의 큰 수를 표현하기위해 자주 사용됨

```python
a = 1e9 
print(a) # 1000000000.0

a = 75.25e1
print(a) # 752.5

a = 3954e-3
print(a) # 3.954
```

컴퓨터 시스템은 실수 정보를 표현하는 정확도에 한계를 가진다.

```python
a = 0.3 + 0.6
print(a) # 0.8999999999999999

if a == 0.9:
  print(True)
else:
  print(False)
# False
```

이럴 때 round()  함수로 반올림으로 처리함

```python
a = 0.3 + 0.6
print(round(a, 4)) # 0.9

if round(a, 4) == 0.9:
  print(True)
else:
  print(False)
# True
```

### 수 자료형의 연산

```python
/ # 나눗셈 연산
% # 나머지 연산
// # 몫 연산
** # 거듭제곱 연산
```

### 리스트 자료형

데이터를 연속적으로 담아서 처리하기 위한 자료형 == 배열, 테이블

```python
# 비어있는 리스트 선언 방법 2가지
a = list()
a = []

# 대괄호 안에 원소를 넣어 초기화, 쉼표로 구분
a = [1, 2, 3, 4, 5]

# 리스트 접근(인덱스 0부터 시작)
print(a[2]) # 3 
```

```python
# 예제
n = 10
a = [0] * n
print(a) # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

#### 리스트 인덱싱과 슬라이싱

- 인덱싱: 인덱스로 리스트의 특정한 원소 접근

  - 인덱스 값은 양수, 음수 모두 접근 가능한데, 음수로 접근하면 리스트에서 원소를 거꾸로 접근한다.

- 슬라이싱: 연속적인위치를 갖는 원소들을 가져옴 (끝 인덱스는 실제 인덱스보다 1 더 크게 설정)

  - 리스트[시작인덱스 : 끝인덱스] 

    ```python
    a = [1, 2, 3, 4, 5]
    a[2 : 4] # 3, 4
    ```

#### 리스트 컴프리헨션: 리스트 초기화 방법 중 하나

```python
array = [i for i in range(10)]
print(array) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```



```python
array = [i for i in range(20) if 1 % 2 == 1]
print(array) # [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]

array = [i * i for i in range(1, 10)]
print(array) # [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

2차원 리스트 초기화할 때 효과적임. 단, 잘못 작성하면 예기치 못한 결과가 나옴.

```python
n = 4
m = 3

# 좋은 예시
array = [[0] * m for _ in range(n)]
print(array) # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]

# 잘못된 예시: 전체 리스트에 포함된 각 리스트가 같은 객체로 인식됨
array = [[0] * m] * n
print(array) # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
array[1][1] = 5
print(array) # [[0, 5, 0], [0, 5, 0], [0, 5, 0], [0, 5, 0]]
```

#### 언더바 

반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할때 사용

```python
for _ in range(5):
  print("Hello World")
```

### 리스트 관련 기타 메서드

| 함수명    | arg                                       | 설명                                 | 시간복잡도 |
| --------- | ----------------------------------------- | ------------------------------------ | ---------- |
| append()  | 변수명.append()                           | 원소 삽입                            | O(1)       |
| sort()    | 변수명.sort() / 변수명.sort(reverse=True) | 오름차순 정렬 / 내림차순 정렬        | O(NlogN)   |
| reverse() | 변수명.reverse()                          | 원소 순서 뒤집기                     | O(N)       |
| insert()  | insert(삽입할 위치 인덱스, 삽입할 값)     | 특정 인덱스 위치에 원소 삽입         | O(N)       |
| count()   | 변수명.count(특정 값)                     | 특정 데이터 개수                     | O(N)       |
| remove()  | 변수명. remove(특정 값)                   | 특정 원소 삭제(여러개면 하나만 삭제) | O(N)       |

### 문자열 자료형

- 큰따옴표나 작은따옴표로 초기화

- 큰따옴표, 작은따옴표를 서로 포함할 수 있다.(" ' ' ", ' " " ')
- 백슬래시\를 사용하면 큰따옴표, 작은따옴표를 문자로 포함할 수 있다.

#### 문자열 연산

##### 덧셈으로 문자열 연결

```python
a = "hello"
b = "world"
print(a + " " + b) # hello world
```

##### 곱셈으로 문자열 여러번 연결

```python
a = 'hello'
print(a * 2) # hellohello
```

##### 인덱싱과 슬라이싱

- 단,  문자열 특정 인덱스 값 변경 불가

```python
a = "abcdef"
print(a[2 : 4]) # cd
```

### 튜플 자료형

리스트와 유사하다

#### 리스트와의 차이점

- 한번 선언된 값을 변경할 수 없다 ➡️ 변경 시, 오류 발생
- 리스트는 대괄호[], 튜플은 소괄호()
- 리스트에 비해 상대적으로 공간 효율적

#### 튜플을 사용하기 좋은 경우

- 서로 다른 성질의 데이터를 묶어서 관리할 때
- 데이터의 나열을 해싱의 키 값으로 사용해야 할 때 (변경이 불가능하므로)
- 리스트보다 메모리를 효율적으로 사용해야 할 때

### 사전 자료형

키와 값을 쌍으로 데이터로 가지는 자료형(cf, 리스트나 튜플은 값을 순차적으로 저장한다)

변경 불가능한 자료형을 키로 사용할 수 있다.

해시 테이블을 사용함으로서 데이터의 조회 및 수정이 O(1)의 시간안에 처리 할 수 있다

```python
data = dict()
data['사과'] = 'apple'
data['바나나'] = 'banana'

data = {
  '사과': 'apple',
  '바나나': 'banana'
}

print(data) # {'사과': 'apple', '바나나': 'banana'}

if '사과' in data:
  print('사과를 키로 가진 데이터 존재') # 사과를 키로 가진 데이터 존재
```

#### 사전 자료형 관련 메서드

| 함수명   | arg                        | 설명                             | 시간복잡도 |
| -------- | -------------------------- | -------------------------------- | ---------- |
| keys()   | 리스트명 = 사전명.keys()   | 키 데이터만 리스트로 뽑아서 이용 |            |
| values() | 리스트명 = 사전명.values() | 값 데이터만 리스트로 뽑아서 이용 |            |

```python
data = dict()
data['사과'] = 'apple'
data['바나나'] = 'banana'

key_list = data.keys()
print(key_list) # dict_keys(['사과', '바나나'])
for key in key_list:
  print(data[key]) 
# apple
# banana

value_list = data.values()
print(value_list) # dict_values(['apple', 'banana'])

key_list = list(b.keys())
print(key_list) # ['사과', '바나나']
```

### 집합 자료형

- 중복 미허용
- 순서 없음
- 초기화 방법
  - 리스트 혹은 문자열로 set(), set({}, {}, ...) 
- 데이터 조회 및 수정 O(1) 시간에 처리

```python
data = set([1, 2, 1, 3, 4, 5, 5])
print(data) # {1, 2, 3, 4, 5}

data = {1, 2, 3, 4, 4}
print(data) # {1, 2, 3, 4}
```

- 연산

  - 합집합
  - 교집합
  - 차집합

  ```python
  a = set([1, 2, 3, 4, 5])
  b = set([3, 4, 5,  6, 7])
  
  print(a | b) # 합집합 연산 결과: {1, 2, 3, 4, 5, 6, 7}
  print(a & b) # 교집합 연산 결과: {3, 4, 5}
  print(a - b) # 차집합 연산 결과: {1, 2}
  ```

  

#### 집합 자료형 관련 함수

| 함수명   | arg                                              | 설명                       | 시간복잡도 |
| -------- | ------------------------------------------------ | -------------------------- | ---------- |
| add()    | 집합자료형.add(새로운원소)                       | 새로운 원소 추가           | O(1)       |
| update() | 집합자료형.update([새로운원소1,새로운원소2,...]) | 새로운 원소 여러 개 추가   | O(1)       |
| remove() | 집합자료형.remove(삭제할원소값)                  | 특정한 값을 갖는 원소 삭제 | O(1)       |



### 사전 자료형과 집합 자료형의 특징

- 리스트나 튜플과 다르게 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다.
- 사전의 키 또는 원소를 이용해서 상수 시간의 시간 복잡도로 조회할 수 있다.



## 기본 입출력

### 표준 입력 방법

- input() : 한줄의 문자열 입력

- map(): 리스트의 모든 원소에 특정 함수 적용

  ```python
  list(map(int, input().split())) # 한줄을 입력받고, 공백을 기준으로 구분된 데이터를 정수형으로 변경해서 리스트로 만듦
  a, b, c = map(int, input().split()) # 한줄을 입력받고, 공백을 기준으로 구분된 데이터를 정수형으로 변경해서 각 변수에 넣음
  ```


- sys.stdin.readline(): 입력을 최대한 빠르게 받는 방법. 단, 엔터가 줄바꿈기호로 입력되므로 rstrip() 메서드 함께 사용

  ```python
  import sys
  
  data = sys.stdin.readline().rstrip()
  ```

### 표준 출력 방법

- print(): 각 변수를 콤마로 띄어쓰기를 구분하여 출력, 기본적으로 줄 바꿈 수행 (원하지 않는 경우 end 속성 이용)

  ```python
  a = 1
  b = 2
  
  print(a, b) # 1 2
  print(7, end=" ")
  print(8, end=" ")
  print("정답은 " + str(a) + "입니다.") # 7 8 정답은 7입니다.
  ```

- 

# 그리디

# DFS & BFS

# 정렬알고리즘

# 이진탐색

# 다이나믹 프로그래밍

# 최단 경로 알고리즘

# 기타 그래프 이론

# 코딩테스트에서 자주 출제되는 기타 알고리즘

# 개발형 코딩 테스트

# 우선순위 큐(Priority Queue)와 힙(Heap)

# 트리(Tree)



# 벨만포드알고리즘

# 바이너리 인덱스 트리(Binary Indexed Tree, BIT, 펜윅 트리)

# 최소 공통조상(Lowest Common Ancestor, LCA)