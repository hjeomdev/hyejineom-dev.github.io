# [구름 에듀 - 스프링부트 나만의 블로그 만들기](https://edu.goorm.io/learn/lecture/24605/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%82%98%EB%A7%8C%EC%9D%98-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0)

몰랐거나 기억해두고 싶은 것 정리

## 1. 환경 세팅

**환경변수**

어떤 경로에 있던 운영체제가 쉽게 프로그램에 접근할 수 있도록, 특정 파일의 경로를 저장한 것이다.



**Spring boot devtools**

캐시를 사용하여 성능 향상 -> 파일 변경 시 자동 재시작 (개발 편리)



**Lombok**

getter, setter, 생성자 자동 생성



**Spring Data JPA** + **MySQL Driver**

ORM을 사용할 수 있는 라이브러리



**Spring Security**

스프링 관련 보안 기능 제공 라이브러리



**Spring Web**

어노테이션 사용을 위한 라이브러리

내장형 컨테이너로 톰캣을 기본탑재하고 있다



**제어의 역전 Inverse Of Control**

스프링이 객체를 생성해서 메모리에 할당하는 것.

싱글톤 패턴 + 레퍼런스 변수를 스프링이 관리 =>  스프링 컨테이너에 변수를 관리

패키지 스캔으로 필요한 변수를 모두 메모리에 로드 -> IoC파일을 패키지 스캔 설정한 패키지 아래에 파일을 생성해야한다

특정 어노테이션이 붙어있는 클래스 파일들을 new해서(IoC) 스프링 컨테이너에서 관리함

패키지 스캔할 클래스에 @Controller 선언



**MySQL UTF-8 설정 (Mac)**

1. MySQL 설정 변경

   ```shell
   vi /usr/local/etc/my.cnf
   ```

   기존에 아래 내용이 저장되어 있었다.

   ```text
   // /usr/local/etc/my.cnf 에 저장되어 있던 내용
   
   # Default Homebrew MySQL server config
   [mysqld]
   # Only allow connections from localhost
   bind-address = 127.0.0.1
   mysqlx-bind-address = 127.0.0.1
   ```

   내용 추가한다.

   ```text
   // /usr/local/etc/my.cnf 에 내용 추가
   
   # Default Homebrew MySQL server config
   [mysqld]
   # Only allow connections from localhost
   bind-address = 127.0.0.1
   mysqlx-bind-address = 127.0.0.1
   
   [mysqld]
   init_connect="SET collation_connection=utf8_general_ci"
   init_connect="SET NAMES utf8"
   character-set-server=utf8
   collation-server=utf8_general_ci
   skip-character-set-client-handshake
   
   [client]
   default-character-set=utf8
   
   [mysql]
   default-character-set=utf8
   ```

   ESC 누른 후 :wq 로 저장하고 나온다.

2. MySQL  재시작

   ```shell
   brew services stop mysql
   brew services start mysql
   ```

   재시작 한 뒤, 데이터베이스에 접속한다.

3. MySQL 설정 확인

   ```sql
   show variables like 'c%';
   ```

   utf-8로 변경된 것을 확인한다.

   ![Screen Shot 2021-11-08 at 2.50.14 PM](/assets/images/spring/Screen Shot 2021-11-08 at 2.50.14 PM.png)



**properties 확장자가 아니라 yaml 확장자를 사용하는 이유**

yaml은 들여쓰기로 구분하여 똑같은 문구를 여러번 적지 않아도 된다.

```properties
#properties 예시
spring.datasource.driver-class-name: com.mysql.cj.jdbc.Driver
spring.datasource.url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul
spring.datasource.username: cos
spring.datasource.password: cos1234
```

```yaml
# yaml 예시
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul
    username: cos
    password: cos1234
```



**Git의 세가지 공간에 대한 비유**

- 작업 영역(폴더) -> 흐르는 뷰
- add
- 인덱스(Index) -> 사진
- commit
- 헤드(HEAD) ->  사진첩



## 2. 시작해봅시다

**HTTP 1.1의 4가지 요청방법**

- GET: 데이터 조회 -> Select
  - 쿼리스트링
    - 요청**?**데이터1=값&데이터2=값&...
- POST: 데이터 추가 -> Insert
  - 바디에 데이터를 넣어서 추가할 데이터 전송

  - 바디에 넣는 방법들
    - form-data
    - x-www-form-urlencoded
    - raw
    - binary
    - GraphQL

- PUT: 데이터 수정 -> Update
- DELETE: 데이터 삭제 -> Delete



**stateless**

클라이언트가 요청 시 마다 스트림을 연결해서 data를 주고 받는 방식

- HTTP 방식
- 세션 유지 어려움
  - session: 데이터를 응답해줄 준비가 됨 == 인증이 되어 있음



**stateful**

클라이언트와 서버의 연결이 지속되는 상태에서 data를 주고 받는 방식

- ex. 채팅
- 세션 유지 쉬움



**패킷 스위칭**

데이터를 패킷 단위로 잘라서 바디에 넣고 데이터의 정보는 헤더에 넣어서 전송

- 데이터 조립 과정 필요 -> 헤더에 저장된 데이터의 정보를 바탕으로 조립
- 헤더에 데이터의 형태를 알려주는 **MIME 타입**이 있다.



**서킷 스위칭**

데이터를 통째로 전송



**[MIME 타입](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types)**

- 형식: type/subtype



**HTTP 데이터 요청 반응**

- 200

  ```text
  // General
  
  Request URL: http://localhost:8080/http/get
  Request Method: GET
  Status Code: 200 
  Remote Address: [::1]:8080
  Referrer Policy: strict-origin-when-cross-origin
  
  // Response Headers
  
  Connection: keep-alive
  Content-Length: 10
  Content-Type: text/html;charset=UTF-8
  Date: Wed, 10 Nov 2021 05:29:08 GMT
  Keep-Alive: timeout=60
  
  // Request Headers
  
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
  Accept-Encoding: gzip, deflate, br
  Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
  Cache-Control: max-age=0
  Connection: keep-alive
  Host: localhost:8080
  sec-ch-ua: "Google Chrome";v="95", "Chromium";v="95", ";Not A Brand";v="99"
  sec-ch-ua-mobile: ?0
  sec-ch-ua-platform: "macOS"
  Sec-Fetch-Dest: document
  Sec-Fetch-Mode: navigate
  Sec-Fetch-Site: none
  Sec-Fetch-User: ?1
  Upgrade-Insecure-Requests: 1
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36
  ```

- [405 해당 메서드 허용되지 않음](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/405)

  ```text
  // General
  
  Request URL: http://localhost:8080/http/post
  Request Method: GET
  Status Code: 405 
  Remote Address: [::1]:8080
  Referrer Policy: strict-origin-when-cross-origin
  
  // Response Headers
  
  Allow: POST
  Connection: keep-alive
  Content-Language: ko-KR
  Content-Length: 4952
  Content-Type: text/html;charset=UTF-8
  Date: Wed, 10 Nov 2021 05:32:13 GMT
  Keep-Alive: timeout=60
  
  // Request Headers
  
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
  Accept-Encoding: gzip, deflate, br
  Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
  Connection: keep-alive
  Host: localhost:8080
  sec-ch-ua: "Google Chrome";v="95", "Chromium";v="95", ";Not A Brand";v="99"
  sec-ch-ua-mobile: ?0
  sec-ch-ua-platform: "macOS"
  Sec-Fetch-Dest: document
  Sec-Fetch-Mode: navigate
  Sec-Fetch-Site: none
  Sec-Fetch-User: ?1
  Upgrade-Insecure-Requests: 1
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36
  ```
  
- **인터넷 브라우저 요청은 무조건 get요청 밖에 할 수 없다.**



**Maven**

프로젝트에 필요한 라이브러리를 관리하는 도구

pom.xml에 작성해두고 서버를 실행하면 필요한 라이브러리를 자동으로 다운받는다.



**@Builder 의 장점**

- 입력 값 순서를 신경쓰지 않아도 된다.



**[yaml 이란](https://www.inflearn.com/questions/16184)**

- XML, JSON보다도 경량의 파일

  - " " 가 없다
  - : 뒤에 공백있다
  - { } 중괄호 대신에 들여쓰기



**application.yml**

아래 모든 설정 합쳐 놓음

- web.xml
- root-context.xml: 싱글톤을 유지하기 위해서 한번만 생성할 객체 지정
- servlet-context.xml: 지속적으로 생성할 객체 지정

```yaml
#application.yml

server:
  port: 8000
  servlet:
    context-path: /blog
    encoding:
      charset: UTF-8
      enabled: true
      force: true
    
spring:
  mvc:
    view:
      prefix: /WEB-INF/views/
      suffix: .jsp
      
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul
    username: cos
    password: cos1234
    
  jpa:
    open-in-view: true
    hibernate:
      ddl-auto: create
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
      use-new-id-generator-mappings: false
    show-sql: true
    properties:
      hibernate.format_sql: true

  jackson:
    serialization:
      fail-on-empty-beans: false
```



- 서버 경로 설정
  1. port
     - 기존 포트: 8080
  2. context-path
     - 기존 context-path: /



- view 경로 설정
```yaml
spring:
  mvc:
    view:
      prefix: /WEB-INF/views/
      suffix: .jsp
```

1. prefix
2. suffix



view 파일에 따라 설정 방법이 다르다

1. 정적인 파일
   - 파일리턴(@Controller) 기본경로: src/main/resources/static
   - 리턴명에 '/'가 들어가야 함
 2. 동적인 파일 (ex. jsp)
    - jsp는 html, png 등과 달리 동적인 파일이라서 src/main/resources/static 아래가 아닌 src/main/webapp/WEB_INF/views 아래에 넣어함





**JPA**

- ORM
  - 다른 언어의 객체를 테이블로 매핑해주는 기술

- @Entity
  - 해당 클래스가 데이터베이스에 테이블로 생성된다.

- @Id
  - @Entity 해당 클래스의 primary key로 설정한다.

- @GeneratedValue(strategy = GenerationType.IDENTITY)
  - 프로젝트에서 연결된 DB의 넘버링 전략을 따른다.

- @Column(nullable = false, length = 30)

- @CreationTimestamp

- @ColumnDefault("'user'")
- @Lob
- @DynamicInsert 
  - insert 시에 null 인 필드 제외시켜
- *@*Enumerated(EnumType.STRING)
  - EnumType 정의하고 해당 Enum을 사용하는 변수에 어노테이션으로 남긴다.
  - 타입이 문자열임을 알린다.
- @Transactional
  - 함수 종료시 자동 commit

```yaml
jpa:
    open-in-view: true
    hibernate:
      ddl-auto: create
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
      use-new-id-generator-mappings: false
    show-sql: true
    properties:
      hibernate.format_sql: true
```

- ddl-auto: create

  - 실행할 때 마다 테이블 새로 만듦
  - 최초 실행 시에만 create라고 하고 이후에 update로 변경해야 함

- show-sql: true

  - 실행하는 sql 보여줌

    ```text
    org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL8Dialect
    Hibernate: 
        
        drop table if exists User
    Hibernate: 
        
        create table User (
           id integer not null auto_increment,
            createDate datetime(6),
            email varchar(50) not null,
            password varchar(100) not null,
            role varchar(255) default 'user',
            username varchar(30) not null,
            primary key (id)
        ) engine=InnoDB
    



- naming: physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
  - @Entity 실행 시 변수명 그대로 테이블 컬럼명으로 설정한다.
- naming: physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
  - myEmail -> my_email로 붙여서 설정한다.



**연관관계의 주인 = FK를 가진 오브젝트**

```java
package com.yazbyz.blog.model;

import java.sql.Timestamp;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.Lob;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;

import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.CreationTimestamp;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
public class Board {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY) // auto_increment
	private int id; 
	
	@Column(nullable = false, length = 100)
	private String title;
	
	@Lob
	private String content;
	
	@ColumnDefault("0")
	private int count;
	
	@ManyToOne(fetch = FetchType.EAGER) // Many = Board, User = One
	@JoinColumn(name = "userId")
	private User user;
	
	@OneToMany(mappedBy = "board", fetch = FetchType.EAGER) // mappedBy 연관관계의 주인이 아니다(난 FK가 아니에요) DB에 칼럼을 만들지 마세요, 반드시 가져와요 
	private List<Reply> reply;
	
	@CreationTimestamp
	private Timestamp createDate;
}

```



```java
@OneToMany(mappedBy = "board", fetch = FetchType.LAZY) // mappedBy 연관관계의 주인이 아니다(난 FK가 아니에요) DB에 칼럼을 만들지 마세요, 필요할때만 가져와요
	private List<Reply> reply;


@OneToMany(mappedBy = "board", fetch = FetchType.EAGER) // mappedBy 연관관계의 주인이 아니다(난 FK가 아니에요) DB에 칼럼을 만들지 마세요, 반드시 가져와요 
	private List<Reply> reply;
```

- @ManyToOne(fetch = FetchType.EAGER) // Many = Board, User = One, 무조건 들고 와야 함

  @JoinColumn(name = "userId")

- @OneToMany(mappedBy = "board",fetch = FetchType.LAZY) // 꼭 들고 오지 않아도 됨



- @ManyToOne
- @OneToMany
- @OneToOne
- @ManyToMany
  - ManyToMany는 사용하지 않는다. 그 이유는 서로의 primary key로만 중간 테이블을 생성해주는데, 날짜나 시간 다른 필드들이 필요할 수 있기 때문에, 내가 중간 테이블을 직접만들고 @OneToMany, @OneToMany를 사용한다.
  - https://ict-nroo.tistory.com/127



**영속성 컨텍스트와 더티체킹**

DB에서 조회한 데이터를 영속성 컨텍스트에 1차 캐시에 저장하여 영속화 한다.

영속화한 객체를 변경하는 함수에 @Transactional 어노테이션이 붙을 경우 종료될 때 자동 커밋된다.

영속성 컨텍스트에서 영속화한 객체의 변경을 감지하고 DB에 업데이트 요청을 넣는다. (변경이 없으면 업데이트 요청을 하지 않는다.)



**JSON 통신**

- GET
  - Body로 데이터 담아 보내지 않음
- POST, PUT, DELETE
  - 데이터 변경
  - form 태그 method='Post' or method='Get' (key=value)
  - 자바스크립트로 요청
- 통일 -> 자바스크립트로 ajax로 요청 + 데이터는 json으로 통일!
- 스프링에 form:form 태그는 다 가능



## **3. 스프링 컨트롤러의 파싱 전략 1**

스프링 컨트롤러는 key=value 데이터를 자동으로 파싱하여 변수에 담아준다.

가령 get요청은 key=value이고 post요청중에 x-www-form-urlencoded (form태그를 만들어서 데이터 전송) 시에도 key=value 이기 때문에 이러한 데이터는 아래와 같이 함수의 파라메터로 받을 수 있다.

```
PostMapping("/home")
public String home(String username, String email){
	
    return "home";
}
```

## **4. 스프링 컨트롤러의 파싱 전략 2**

스프링은 key=value 형태의 데이터를 오브젝트로 파싱해서 받아주는 역할도 한다.

** 이때 주의 할점은 setter가 없으면 key=value 데이터를 스프링이 파싱해서 넣어주지 못한다.

```
class User {
	private String username;
    private String password;
    
    public String getUsername(){
    	return username;
    }
    
    public String getPassword(){
    	return password;
    }
    
    public void setUsername(String username){
    	this.username = username;
    }
    
    public void setPassword(String password){
    	this.password = password;
    }
    
}
PostMapping("/home")
public String home(User user){
	
    return "home";
}
```

## **5. key=value가 아닌 데이터는 어떻게 파싱할까?**

json 데이터나 일반 text데이터는 스프링 컨트롤러에서 받기 위해서는 @RequestBody 어노테이션이 필요하다.

** 기본전략이 스프링 컨트롤러는 key=value 데이터를 파싱해서 받아주는 일을 하는데 다른 형태의 데이터 가령 json 같은 데이터는 아래와 같이 생겼다.

```
{
    "username":"ssar",
    "password":"1234"
}
```

이런 데이터는 스프링이 파싱해서 오브젝트로 받지 못한다. 그래서 @RequestBody 어노테이션을 붙이면 MessageConverter 클래스를 구현한 Jackson 라이브러리가 발동하면서 json 데이터를 자바 오브젝트로 파싱하여 받아준다.

```
PostMapping("/home")
public String home(@RequestBody User user){
	
    return "home";
}
```

## **6. form 태그로 json데이터 요청방법**

key=value 데이터가 아니라 json데이터를 어떻게 전송할 수 있을까?

### **join.jsp**

```
<div class="container">

	<form>
		<div class="form-group">
			<label for="username">유저네임</label> 
			<input type="text" id="username">
		</div>
		<div class="form-group">
			<label for="password">패스워드</label> 
			<input type="password" id="password">
		</div>
		
		<div class="form-group">
			<label for="email">이메일</label> 
			<input type="email" id="email">
		</div>
	</form>
	
	<button id="join--submit" class="btn btn-primary">회원가입</button>

</div>

<script src="/js/join.js"></script>
```

### **join.js**

```
<script>
$('#join--submit').on('click', function() {
	var data = {
		username : $('#username').val(),
		password : $('#password').val(),
		email : $('#email').val()
	};

	$.ajax({
		type : 'POST',
		url : '/user/join',
		data : JSON.stringify(data),
		contentType : 'application/json; charset=utf-8',
		dataType : 'json'
	}).done(function(r) {
		if (r.statusCode == 200) {
			console.log(r);
			alert('회원가입 성공');
			location.href = '/user/login';
		} else {
			if (r.msg == '아이디중복') {
				console.log(r);
				alert('아이디가 중복되었습니다.');
			} else {
				console.log(r);
				alert('회원가입 실패');
			}
		}
	}).fail(function(r) {
		var message = JSON.parse(r.responseText);
		console.log((message));
		alert('서버 오류');
	});
});
</script>
```

 



**7. 무한 참조 방지하기**

(1) Entity로 받고 Json직렬화 하기 전에 DTO 생성후 복사하기

BeanUtils.copyProperties(A,B)

(2) 처음부터 DTO로 DB에서 받기

(3) @JsonIgnore

(4) @JsonIgnoreProperties({"board"})

(5) @JsonBackReference @JsonManagedReference\

 

**참고** 

[https://dublin-java.tistory.com/32](https://dublin-java.tistory.com/32)



**Ajax를 사용하는 이유**

1. 요청에 대한 응답을 html이 아닌 Data(json)를 받기 위해서
   - 각 요청에 맞게 html과 json을 반환하는 각각의 서버가 필요하다.
2. 순서에 상관없이 비동기 통신을 하기 위해서



**Service를 사용하는 이유**

1. 여러 트랜잭션을 한번에 관리
   - 트랜잭션: 일이 처리되기 위한 가장 작은 단위
2. 서비스 의미 때문



**DB 격리 수준 READ COMMIT을 위한 @Transactional**

트랜잭션이 두개라고 생각하고, 

한 트랜잭션(T12)이 데이터 변경 쿼리문이 요청되면 READ하는 다른 트랜잭션(T11)은 커밋하기 전까지 undo 영역의 데이터를 read 한다.

하지만 커밋을 하고나면(=트랜잭션 종료) undo 영역의 데이터도 변경되어 commit이전에 요청한 read와 다른 데이터를 반환될 수 있다.

요청마다 결과가 다르게 보이는 문제를 ==READ COMMIT의 정합성이 깨진다(= PHANTON READ)==라고 한다.

이 문제의 해결방법은 ==REPEATEABLE READ==이다.

리핏터블 리드는 자기 트랜잭션 번호보다 낮은 undo 로그를 보고 리드하는 것이다.

이러면 T11은 T10의 로그를 보고 리드하게 되고 T12가 변경한 내용은 리드하지 않는다.

단 트랜잭션을 시작해야 이전 트랜잭션의 로그를 확인할 수 있다.

==스프링에 정합성을 위해서 select 할때도 @Transactional 어노테이션을 붙인다.==



**스프링의 전통적인 트랜잭션**

![Screen Shot 2021-11-26 at 10.24.20 PM](/assets/images/spring/Screen Shot 2021-11-26 at 10.24.20 PM.png)

- 스프링 시작 과정

  1. 톰캣 시작: 서버 작동
  2. web.xml 
  3. context.xml -> 데이터베이스 연결 테스트

- request 요청

  1. web.xml

     (1) DB 연결 세션 생성

     (2) 트랜잭션 시작

  2. 필터

  3. 스프링 컨테이너

     - 컨트롤러

       - request: 요청을 확인해서 요청에 해당하는 서비스 호출

       - response: data(json), html 형식의 데이터 전송

       (3) 트랜잭션 종료(커밋)

       (5) DB 연결 세션 종료

     - 서비스: 컨트롤러의 요청에 따라 호출된 서비스가 레포지토리에서 받은 객체를 변경

     - 레포지토리: 영속성 컨텍스트에서 객체를 받아서 서비스에게 전달

  4. 영속성 컨텍스트: 필요한 데이터를 DB에서 select해서 영속성 컨텍스트에 객체화해서 저장

  5. DB

     (4) 변경 감지  



**기존 스프링 JPA의 OSIV 전략**

- ManyToOne(EAGER)

![Screen Shot 2021-11-27 at 12.18.13 AM](/assets/images/spring/Screen Shot 2021-11-27 at 12.18.13 AM.png)

- ManyToOne(LAZY)

  ![Screen Shot 2021-11-27 at 12.22.30 AM](/assets/images/spring/Screen Shot 2021-11-27 at 12.22.30 AM.png)

  application.yml에서 spring: jpa: open-in-view: true

```yaml
# application.yml
spring:
  ...
    
  jpa:
    open-in-view: true
    hibernate:
      ddl-auto: update
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
      use-new-id-generator-mappings: false
    show-sql: true
    properties:
      hibernate.format_sql: true

  ...
```

[**3. 스프링부트의 트랜잭션**](https://getinthere.tistory.com/27?category=884180)

\- 세션의 시작은 서블릿이 시작되는 시점 부터~ (세션은 영속성 컨텍스트를 포함)

\- 트랜잭션의 시작은 서비스 레이어부터, JDBC 커넥션도 이 시점부터.

\- 트랜잭션의 종료는 서비스 계층에서 종료, JDBC 커넥션도 이 시점 부터 종료.

\- 세션은 컨트롤러 영역까지 끌고 가기 때문에 영속성이 보장되어 select가 가능해지고 lazy-loading이 가능해진다.



![img](/assets/images/spring/img.png)

![img](/assets/images/spring/img.jpg)

[**(3) open-in-view**](https://getinthere.tistory.com/20?category=884180)

```
org.springframework.orm.hibernate3.support.OpenSessionInViewFilter 클래스
```

영속성을 프리젠테이션 계층까지 가져간다. 트랜잭션은 Service계층에서 종료된다. Transaction이 종료된 후에도 Controller의 Session이 close되지 않았기 때문에, 영속 객체는 Persistence 상태를 유지할 수 있으며, 따라서 프록시 객체에 대한 Lazy Loading을 수행할 수 있게 된다.

버전 2.0부터 스프링 부트는 기본적으로 OSIV가 활성화되어있을 때 경고를 발행하므로 프로덕션 시스템에 영향을 주기 전에 이 문제를 발견 할 수 있다.





![img](/assets/images/spring/img-20211127002758057.png)



서블릿 필터에서 Session 을 오픈하고 트랜잭션을 시작하던 전통적인 방식의 OPEN SESSION IN VIEW 패턴과 달리 SpringMVC 에서 제공하는 OpenSessionInViewFilter 는 필터 내에서 Session 은 오픈하지만 트랜잭션은 시작하지 않는다. 따라서 서블릿 필터 안에서는 커넥션 풀로부터 JDBC 커넥션을 얻을 필요가 없다.

```
hibernate.enable_lazy_load_no_trans: true  
```

OSIV를 활성화 하였다면 위에 옵션을 필요 없다. 그리고 OSIV는 스프링부트가 디폴트로 활성화하고 있는 옵션이다. 경고를 제거하기 위해 명확하게 적어준 것 뿐!!



![img](/assets/images/spring/img-20211127002758042.png)



![Screen Shot 2021-11-27 at 12.34.08 AM](/assets/images/spring/Screen Shot 2021-11-27 at 12.34.08 AM.png)

![Screen Shot 2021-11-27 at 12.34.49 AM](/assets/images/spring/Screen Shot 2021-11-27 at 12.34.49 AM.png)





**CSRF, XSS**

XSS: 자바스크립트 공격

- 해결방안
  - 보안에 신경써야하는 요청은 post로 요청하기
  - CSRF Token 사용























